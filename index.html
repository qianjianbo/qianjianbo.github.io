<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>啵啵啵</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="啵啵啵">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="啵啵啵">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="啵啵啵">
  
  
    <link rel="icon" href="https://avatars0.githubusercontent.com/u/20942842?v=3&u=d1a97114e82a12c99a99e1cf4d13fffad7756cd7&s=140">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="https://avatars0.githubusercontent.com/u/20942842?v=3&amp;u=d1a97114e82a12c99a99e1cf4d13fffad7756cd7&amp;s=140" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">qianjenbo</a></h1>
		</hgroup>

		
		<p class="header-subtitle">有时候缺的就是破釜沉舟的勇气，把自己逼一逼，才知道自己有多大潜力！</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="http://www.suibi8.com/">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/qianjianbo" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://t.qq.com/qianjianbo777?preview" title="weibo">weibo</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">qianjenbo</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://avatars0.githubusercontent.com/u/20942842?v=3&amp;u=d1a97114e82a12c99a99e1cf4d13fffad7756cd7&amp;s=140" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">qianjenbo</h1>
			</hgroup>
			
			<p class="header-subtitle">有时候缺的就是破釜沉舟的勇气，把自己逼一逼，才知道自己有多大潜力！</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="http://www.suibi8.com/">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/qianjianbo" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://t.qq.com/qianjianbo777?preview" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="玩转html5-canvas画图" class="article article-type-玩转html5" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/16/canvas画图/">canvas画图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><ul>
<li>前言</li>
<li>基本知识</li>
<li>绘制矩形</li>
<li>清除矩形区域</li>
<li>圆弧</li>
<li>路径</li>
<li>绘制线段</li>
<li>绘制贝塞尔曲线</li>
<li>线性渐变</li>
<li>径向渐变（发散）</li>
<li>图形变形（平移、旋转、缩放）</li>
<li>矩阵变换（图形变形的机制）</li>
<li>图形组合</li>
<li>给图形绘制阴影</li>
<li>绘制图像（图片平铺、裁剪、像素处理[不只图像、包括其他绘制图形]）</li>
<li>绘制文字</li>
<li>保存和恢复状态（context）</li>
<li>保存文件</li>
<li>结合setInterval制作动画</li>
<li>结语、demo下载</li>
</ul>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><pre><code>&lt;canvas&gt;&lt;/canvas&gt;是html5出现的新标签，像所有的dom对象一样它有自己本身的属性、方法和事件，其中就有绘图的方法，js能够调用它来进行绘图 ，最近在研读《html5与css3权威指南》下面对其中最好玩的canvas的学习做下读书笔记与实验。
</code></pre><p>温馨提示：以下所有实验请使用最新版的opera</p>
<h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>context:一直觉得这个翻译成“上下文”真够蛋疼的，context是一个封装了很多绘图功能的对象，获取这个对象的方法是</p>
<p>var context =canvas.getContext(“2d”);</p>
<p>也许这个2d勾起了大家的无限遐想，但是很遗憾的告诉你html5还只是个少女，不提供3d服务。</p>
<p>canvas元素绘制图像的时候有两种方法，分别是</p>
<p>context.fill()//填充</p>
<p>context.stroke()//绘制边框</p>
<p>style:在进行图形绘制前，要设置好绘图的样式</p>
<p>context.fillStyle//填充的样式</p>
<p>context.strokeStyle//边框样式</p>
<p>context.lineWidth//图形边框宽度</p>
<p>颜色的表示方式:</p>
<p>直接用颜色名称:”red” “green” “blue”</p>
<p>十六进制颜色值: “#EEEEFF”</p>
<p>rgb(1-255,1-255,1-255)</p>
<p>rgba(1-255,1-255,1-255,透明度)</p>
<p>和GDI是如此的相像，所以用过GDI的朋友应该很快就能上手</p>
<h5 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h5><p>context.fillRect(x,y,width,height) strokeRect(x,y,width,height)</p>
<p>x:矩形起点横坐标（坐标原点为canvas的左上角，当然确切的来说是原始原点，后面写到变形的时候你就懂了，现在暂时不用关系）</p>
<p>y:矩形起点纵坐标</p>
<p>width:矩形长度</p>
<p>height:矩形高度</p>
<pre><code>View Code 
 function draw21(id) {
         var canvas = document.getElementById(id)
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         //实践表明在不设施fillStyle下的默认fillStyle=black
         context.fillRect(0, 0, 100, 100);
         //实践表明在不设施strokeStyle下的默认strokeStyle=black
         context.strokeRect(120, 0, 100, 100);

         //设置纯色
         context.fillStyle = &quot;red&quot;;
         context.strokeStyle = &quot;blue&quot;;
         context.fillRect(0, 120, 100, 100);
         context.strokeRect(120, 120, 100, 100);

         //设置透明度实践证明透明度值&gt;0,&lt;1值越低，越透明，值&gt;=1时为纯色，值&lt;=0时为完全透明
         context.fillStyle = &quot;rgba(255,0,0,0.2)&quot;;
         context.strokeStyle = &quot;rgba(255,0,0,0.2)&quot;;
         context.fillRect(240,0 , 100, 100);
         context.strokeRect(240, 120, 100, 100);
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/2012082241.jpg" alt="Mou"></p>
<h4 id="清除矩形区域"><a href="#清除矩形区域" class="headerlink" title="清除矩形区域"></a>清除矩形区域</h4><p>context.clearRect(x,y,width,height)</p>
<p>x:清除矩形起点横坐标</p>
<p>y:清除矩形起点纵坐标</p>
<p>width:清除矩形长度</p>
<p>height:清除矩形高度</p>
<pre><code>View Code 
   function draw22(id) {
         var canvas = document.getElementById(id)
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         //实践表明在不设施fillStyle下的默认fillStyle=black
         context.fillRect(0, 0, 100, 100);
         //实践表明在不设施strokeStyle下的默认strokeStyle=black
         context.strokeRect(120, 0, 100, 100);

         //设置纯色
         context.fillStyle = &quot;red&quot;;
         context.strokeStyle = &quot;blue&quot;;
         context.fillRect(0, 120, 100, 100);
         context.strokeRect(120, 120, 100, 100);

         //设置透明度实践证明透明度值&gt;0,&lt;1值越低，越透明，值&gt;=1时为纯色，值&lt;=0时为完全透明
         context.fillStyle = &quot;rgba(255,0,0,0.2)&quot;;
         context.strokeStyle = &quot;rgba(255,0,0,0.2)&quot;;
         context.fillRect(240, 0, 100, 100);
         context.strokeRect(240, 120, 100, 100);
         context.clearRect(50, 50, 240, 120);
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/2012082242.jpg" alt="Mou"></p>
<h3 id="圆弧"><a href="#圆弧" class="headerlink" title="圆弧"></a>圆弧</h3><p>context.arc(x, y, radius, starAngle,endAngle, anticlockwise)</p>
<p>x:圆心的x坐标</p>
<p>y:圆心的y坐标</p>
<p>straAngle:开始角度</p>
<p>endAngle:结束角度</p>
<p>anticlockwise:是否逆时针（true）为逆时针，(false)为顺时针</p>
<p>ps：经过试验证明书本上ture是顺时针，false是逆时针是错误的，而且无论是逆时针还是顺时针，角度都沿着顺时针扩大，如下图：</p>
<p><img src="http://www.uml.org.cn/html/images/2012082243.png" alt="Mou"></p>
<pre><code>View Code 
     function draw0(id) {
         var canvas = document.getElementById(id);
         if (canvas == null) {
             return false;
         }
         var context = canvas.getContext(&apos;2d&apos;);
         context.beginPath();
         context.arc(200, 150, 100, 0, Math.PI * 2, true);
         //不关闭路径路径会一直保留下去，当然也可以利用这个特点做出意想不到的效果
         context.closePath();
         context.fillStyle = &apos;rgba(0,255,0,0.25)&apos;;
         context.fill();
     } 
</code></pre><p>一不小心画了小日本的国旗…赶紧调下颜色和大小，绿色倒是挺合适的~</p>
<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>context.beginPath() context.closePath()</p>
<p>细心的朋友会发现上面的画圆并不单单是直接用arc还用到了context的 beginPath 和closePath方法，参考书不愧是参考书，例子给得太简单了，实话说一开始我凌乱了，耐心下来做了几个实验才舒缓蛋疼的心情</p>
<p>实验代码如下，通过分别注释closePath 和beginPath看fill stoke 和fill stroke结合下画出来的两个1/4弧线达到实验效果</p>
<pre><code>View Code 
   function draw23(id) {
         var canvas = document.getElementById(id);
         if (canvas == null) {
             return false;
         }
         var context = canvas.getContext(&apos;2d&apos;);
         var n = 0;

         //左侧1/4圆弧
         context.beginPath();
         context.arc(100, 150, 50, 0, Math.PI/2 , false);
         context.fillStyle = &apos;rgba(255,0,0,0.25)&apos;;
         context.fill();
         context.strokeStyle = &apos;rgba(255,0,0,0.25)&apos;
         context.closePath();
         context.stroke();

         //右侧1/4圆弧
         context.beginPath();
         context.arc(300, 150, 50, 0, Math.PI/2 , false);
         context.fillStyle = &apos;rgba(255,0,0,0.25)&apos;;
         context.fill();
         context.strokeStyle = &apos;rgba(255,0,0,0.25)&apos;;
         context.closePath();
         context.stroke();
     } 
</code></pre><p>实验结果如下：<br> <img src="http://www.uml.org.cn/html/images/2012082245.png" alt="Mou"><br> 得出的结论有：*号为重点</p>
<p>1、系统默认在绘制第一个路径的开始点为beginPath</p>
<p>*2、如果画完前面的路径没有重新指定beginPath，那么画第其他路径的时候会将前面最近指定的beginPath后的全部路径重新绘制</p>
<p>3、每次调用context.fill（）的时候会自动把当次绘制的路径的开始点和结束点相连，接着填充封闭的部分</p>
<p>ps：书本的结论是 如果没有closePath那么前面的路劲会保留，实验证明正确的结论是 如果没有重新beginPath那么前面的路劲会保留</p>
<p>ps1：如果你真心凌乱了，那么记住每次画路径都在前后加context.beginPath() 和context.closePath()就行</p>
<p>绘制线段 context.moveTo(x,y) context.lineTo(x,y)</p>
<p>x:x坐标</p>
<p>y:y坐标</p>
<p>每次画线都从moveTo的点到lineTo的点，</p>
<p>如果没有moveTo那么第一次lineTo的效果和moveTo一样，</p>
<p>每次lineTo后如果没有moveTo，那么下次lineTo的开始点为前一次lineTo的结束点</p>
<pre><code>View Code 
 function draw8(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         //context.beginPath();
         context.strokeStyle = &quot;rgb(250,0,0)&quot;;
         context.fillStyle = &quot;rgb(250,0,0)&quot;
         //实验证明第一次lineTo的时候和moveTo功能一样
         context.lineTo(100, 100);
         //之后的lineTo会以上次lineTo的节点为开始
         context.lineTo(200, 200);
         context.lineTo(200, 100);
         context.moveTo(200, 50);
         context.lineTo(100,50);
         context.stroke();
     } 
</code></pre><p> <img src="http://www.uml.org.cn/html/images/2012082246.png" alt="Mou"></p>
<p> 下面给出书本的例子，一朵绿色的菊花，涉及数学，不多解析，有兴趣的自己研究</p>
<pre><code>View Code 
   function draw1(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         context.fillStyle = &quot;#EEEEFF&quot;;
         context.fillRect(0, 0, 400, 300);
         var n = 0;
         var dx = 150;
         var dy = 150;
         var s = 100;
         context.beginPath();
         context.fillStyle = &apos;rgb(100,255,100)&apos;;
         context.strokeStyle = &apos;rgb(0,0,100)&apos;;
         var x = Math.sin(0);
         var y = Math.cos(0);
         var dig = Math.PI / 15 * 11;
         for (var i = 0; i &lt; 30; i++) {
             var x = Math.sin(i * dig);
             var y = Math.cos(i * dig);
             context.lineTo(dx + x * s, dy + y * s);
         }
         context.closePath();
         context.fill();
         context.stroke();

     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/2012082247.png" alt="Mou"></p>
<h3 id="绘制贝塞尔曲线"><a href="#绘制贝塞尔曲线" class="headerlink" title="绘制贝塞尔曲线"></a>绘制贝塞尔曲线</h3><p>（贝济埃、bezier） context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y)</p>
<p>绘制二次样条曲线 context.quadraticCurveTo(qcpx,qcpy,qx,qy)</p>
<p>cp1x:第一个控制点x坐标</p>
<p>cp1y:第一个控制点y坐标</p>
<p>cp2x:第二个控制点x坐标</p>
<p>cp2y:第二个控制点y坐标</p>
<p>x:终点x坐标</p>
<p>y:终点y坐标</p>
<p>qcpx:二次样条曲线控制点x坐标</p>
<p>qcpy:二次样条曲线控制点y坐标</p>
<p>qx:二次样条曲线终点x坐标</p>
<p>qy:二次样条曲线终点y坐标</p>
<pre><code>View Code 
     function draw24(id) {
         var canvas = document.getElementById(id);
         if (canvas == null) {
             return false;
         }
         var context = canvas.getContext(&quot;2d&quot;);

         context.moveTo(50, 50);
         context.bezierCurveTo(50, 50,150, 50, 150, 150);
         context.stroke();
         context.quadraticCurveTo(150, 250, 250, 250);
         context.stroke();
     } 
</code></pre><p>  <img src="http://www.uml.org.cn/html/images/2012082248.png" alt="Mou"><br>  下面给出书本的例子，一朵扭曲的绿色菊花…编书这哥们对菊花情有独钟啊- -</p>
<pre><code>View Code 
     function draw2(id) {
         var canvas = document.getElementById(id);
         if (canvas == null) {
             return false;
         }
         var context = canvas.getContext(&quot;2d&quot;);
         context.fillStyle = &quot;#EEEFF&quot;;
         context.fillRect(0, 0, 400, 300);
         var n = 0;
         var dx = 150;
         var dy = 150;
         var s = 100;
         context.beginPath();
         context.globalCompositeOperation = &apos;and&apos;;
         context.fillStyle = &apos;rgb(100,255,100)&apos;;
         var x = Math.sin(0);
         var y = Math.cos(0);
         var dig = Math.PI / 15 * 11;
         context.moveTo(dx, dy);
         for (var i = 0; i &lt; 30; i++) {
             var x = Math.sin(i * dig);
             var y = Math.cos(i * dig);
             context.bezierCurveTo(dx + x * s, dy + y * s - 100, dx + x * s + 100, dy + y * s, dx + x * s, 
              dy + y * s);
         }
         context.closePath();
         context.fill();
         context.stroke();
     }   
</code></pre><p>  <img src="http://www.uml.org.cn/html/images/2012082249.png" alt="Mou">    </p>
<h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><p>var lg= context.createLinearGradient(xStart,yStart,xEnd,yEnd)</p>
<p>线性渐变颜色lg.addColorStop(offset,color)</p>
<p>xstart:渐变开始点x坐标</p>
<p>ystart:渐变开始点y坐标</p>
<p>xEnd:渐变结束点x坐标</p>
<p>yEnd:渐变结束点y坐标</p>
<p>offset:设定的颜色离渐变结束点的偏移量(0~1)</p>
<p>color:绘制时要使用的颜色</p>
<p>给出书本偏移量的解析图，从图可以看出线性渐变可以是两种以上颜色的渐变</p>
<p><img src="http://www.uml.org.cn/html/images/20120822410.png" alt="Mou">  </p>
<pre><code>View Code 
     function draw25(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&apos;2d&apos;);
         var g1 = context.createLinearGradient(0, 0, 0, 300);

         g1.addColorStop(0, &apos;rgb(255,0,0)&apos;); //红 
         g1.addColorStop(0.5, &apos;rgb(0,255,0)&apos;);//绿
         g1.addColorStop(1, &apos;rgb(0,0,255)&apos;); //蓝

         //可以把lg对象理解成GDI中线性brush
         context.fillStyle = g1;
         //再用这个brush来画正方形
          context.fillRect(0, 0, 400, 300); 
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822411.png" alt="Mou">  </p>
<h3 id="径向渐变（发散）"><a href="#径向渐变（发散）" class="headerlink" title="径向渐变（发散）"></a>径向渐变（发散）</h3><p>var rg=context.createRadialGradient(xStart,yStart,radiusStart,xEnd,yEnd,radiusEnd)</p>
<p>径向渐变（发散）颜色rg.addColorStop(offset,color)</p>
<p>xStart:发散开始圆心x坐标</p>
<p>yStart:发散开始圆心y坐标</p>
<p>radiusStart:发散开始圆的半径</p>
<p>xEnd:发散结束圆心的x坐标</p>
<p>yEnd:发散结束圆心的y坐标</p>
<p>radiusEnd:发散结束圆的半径</p>
<p>offset:设定的颜色离渐变结束点的偏移量(0~1)</p>
<p>color:绘制时要使用的颜色</p>
<p>书本并没有给出发散偏移量的图，特地画了幅：</p>
<p><img src="http://www.uml.org.cn/html/images/20120822412.png" alt="Mou"><br>下面给出两个实验</p>
<pre><code>View Code 
     function draw26(id) {
         //同一个圆心画球型
         /*var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&apos;2d&apos;);
         var g1 = context.createRadialGradient(200, 150, 0, 200, 150, 100);
         g1.addColorStop(0.1, &apos;rgb(255,0,0)&apos;);  
         g1.addColorStop(1, &apos;rgb(50,0,0)&apos;);
         context.fillStyle = g1;
         context.beginPath();
         context.arc(200, 150, 100, 0, Math.PI * 2, true);
         context.closePath();
         context.fill();*/

         //不同圆心看径向渐变模型
         var canvas = document.getElementById(id);
         if (canvas == null)
         return false;
         var context = canvas.getContext(&apos;2d&apos;);
         var g1 = context.createRadialGradient(100, 150, 10, 300, 150, 50);
         g1.addColorStop(0.1, &apos;rgb(255,0,0)&apos;);
         g1.addColorStop(0.5, &apos;rgb(0,255,0)&apos;);
         g1.addColorStop(1, &apos;rgb(0,0,255)&apos;);
         context.fillStyle = g1;
         context.fillRect(0, 0, 400, 300);

     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822413.png" alt="Mou">   </p>
<p><img src="http://www.uml.org.cn/html/images/20120822414.png" alt="Mou">   </p>
<h3 id="图形变形"><a href="#图形变形" class="headerlink" title="图形变形"></a>图形变形</h3><p>1、平移context.translate(x,y)</p>
<p>x:坐标原点向x轴方向平移x</p>
<p>y:坐标原点向y轴方向平移y</p>
<p>2、缩放context.scale(x,y)</p>
<p>x:x坐标轴按x比例缩放</p>
<p>y:y坐标轴按y比例缩放</p>
<p>3、旋转context.rotate(angle)</p>
<p>angle:坐标轴旋转x角度（角度变化模型和画圆的模型一样）</p>
<pre><code>View Code 
     function draw5(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;


         var context = canvas.getContext(&quot;2d&quot;);
         context.save(); //保存了当前context的状态
         context.fillStyle = &quot;#EEEEFF&quot;;
         context.fillRect(0, 0, 400, 300);

         context.fillStyle = &quot;rgba(255,0,0,0.1)&quot;;
         //平移 缩放 旋转  1 2 3        
         context.translate(100, 100);
         context.scale(0.5, 0.5);
         context.rotate(Math.PI / 4);
         context.fillRect(0, 0, 100, 100);


         context.restore(); //恢复到刚刚保存的状态,保存恢复只能使用一次
         context.save(); //保存了当前context的状态
         context.fillStyle = &quot;rgba(255,0,0,0.2)&quot;;
         //平移 旋转 缩放 1 3 2
         context.translate(100, 100);
         context.rotate(Math.PI / 4);
         context.scale(0.5, 0.5);
         context.fillRect(0, 0, 100, 100);

         context.restore(); //恢复到刚刚保存的状态
         context.save(); //保存了当前context的状态
         context.fillStyle = &quot;rgba(255,0,0,0.3)&quot;;
         //缩放 平移 旋转 2 1 3 
         context.scale(0.5, 0.5);
         context.translate(100, 100);
         context.rotate(Math.PI / 4);
         context.fillRect(0, 0, 100, 100);

         context.restore(); //恢复到刚刚保存的状态
         context.save(); //保存了当前context的状态
         context.fillStyle = &quot;rgba(255,0,0,0.4)&quot;;
         //缩放 旋转 平移  2 3  1 
         context.scale(0.5, 0.5);
         context.rotate(Math.PI / 4);
         context.translate(100, 100);
         context.fillRect(0, 0, 100, 100);

         context.restore(); //恢复到刚刚保存的状态
         context.save(); //保存了当前context的状态
         context.fillStyle = &quot;rgba(255,0,0,0.5)&quot;;
         //旋转 平移 缩放  3 1 2 
         context.rotate(Math.PI / 4);
         context.translate(100, 100);
         context.scale(0.5, 0.5);
         context.fillRect(0, 0, 100, 100);

         context.restore(); //恢复到刚刚保存的状态
         context.save(); //保存了当前context的状态
         context.fillStyle = &quot;rgba(255,0,0,1)&quot;;
         //旋转 缩放 平移   3 2 1 
         context.rotate(Math.PI / 4);
         context.scale(0.5, 0.5);
         context.translate(100, 100);
         context.fillRect(0, 0, 100, 100);

         //实验表明应该移动的是坐标轴
         //实验表明缩放的是坐标轴比例
         //实验表明旋转的是坐标轴
         //综合上述，因此平移 缩放 旋转 三者的顺序不同都将画出不同的结果
     } 
</code></pre><p>由于（平移，缩放，旋转）和（平移，旋转，缩放）一样</p>
<p>（缩放，选装，平移）和（旋转，缩放，平移）一样</p>
<p>所以实验结果只能看到“4”中情况，其实是有两种情况被覆盖了</p>
<p><img src="http://www.uml.org.cn/html/images/20120822415.png" alt="Mou"><br>下面给出平移，缩放，旋转先后顺序不同，坐标轴的变化图<br><img src="http://www.uml.org.cn/html/images/20120822416.png" alt="Mou">   </p>
<h3 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h3><p>context.transform(m11,m12,m21,m22,dx,dy)</p>
<p>所谓的矩阵变换其实是context内实现平移，缩放，旋转的一种机制</p>
<p>他的主要原理就是矩阵相乘</p>
<p>额，要讲解这个可以另开一个篇幅，庆幸的是已经有人做了总结，可以参考下面这篇文章</p>
<p><a href="http://hi.baidu.com/100912bb_bb/item/90c4a7489518b0fa1281daf1" target="_blank" rel="external">http://hi.baidu.com/100912bb_bb/item/90c4a7489518b0fa1281daf1</a></p>
<p>我们需要了解的是</p>
<p>context.translate(x,y) 等同于context.transform (1,0,0,1,x,y)或context.transform(0,1,1,0.x,y)</p>
<p>context.scale(x,y)等同于context.transform(x,0,0,y,0,0)或context.transform (0,y,x,0, 0,0);</p>
<p>context.rotate(θ)等同于 context.transform(Math.cos(θ<em>Math.PI/180)，Math.sin(θ</em>Math.PI/180), -Math.sin(θ<em>Math.PI/180),Math.cos(θ</em>Math.PI/180)，0，0） 或 context.transform(-Math.sin(θ<em>Math.PI/180),Math.cos(θ</em>Math.PI/180)， Math.cos(θ<em>Math.PI/180)，Math.sin(θ</em>Math.PI/180), 0，0）</p>
<h3 id="图形组合"><a href="#图形组合" class="headerlink" title="图形组合"></a>图形组合</h3><p>context.globalCompositeOperation=type</p>
<p>图形组合就是两个图形相互叠加了图形的表现形式,是后画的覆盖掉先画的呢，还是相互重叠的部分不显示等等，至于怎么显示就取决于type的值了</p>
<p>type：</p>
<p>source-over（默认值）:在原有图形上绘制新图形</p>
<p>destination-over:在原有图形下绘制新图形</p>
<p>source-in:显示原有图形和新图形的交集，新图形在上，所以颜色为新图形的颜色</p>
<p>destination-in:显示原有图形和新图形的交集，原有图形在上，所以颜色为原有图形的颜色</p>
<p>source-out:只显示新图形非交集部分</p>
<p>destination-out:只显示原有图形非交集部分</p>
<p>source-atop:显示原有图形和交集部分，新图形在上，所以交集部分的颜色为新图形的颜色</p>
<p>destination-atop:显示新图形和交集部分，新图形在下，所以交集部分的颜色为原有图形的颜色</p>
<p>lighter:原有图形和新图形都显示，交集部分做颜色叠加</p>
<p>xor:重叠飞部分不现实</p>
<p>copy:只显示新图形</p>
<p>文字看得人眼花缭乱，特意画图一张：回头一看惊觉打错字，图片的原型为圆形，你懂的- -<br><img src="http://www.uml.org.cn/html/images/20120822417.png" alt="Mou"><br>以下为实验代码</p>
<pre><code>View Code 
     function draw10(id) {
         var canvas = document.getElementById(id);
         if (canvas == null) {
             return false;
         }
         var context = canvas.getContext(&quot;2d&quot;);
         var oprtns = new Array(
         &quot;source-over&quot;,
         &quot;destination-over&quot;,
         &quot;source-in&quot;,
         &quot;destination-in&quot;,
         &quot;source-out&quot;,
         &quot;destination-out&quot;,
         &quot;source-atop&quot;,
         &quot;destination-atop&quot;,
         &quot;lighter&quot;,
         &quot;xor&quot;,         
         &quot;copy&quot;
         );
        var i = 0;//组合效果编号

        //结合setinterval动态显示组合
        var interal = setInterval(function () {
            if (i == 10) {
                i=0;
            }
            else {
                i++;
            }
            //蓝色矩形
            context.fillStyle = &quot;blue&quot;;
            context.fillRect(10, 10, 60, 60);
            //设置组合方式 
            context.globalCompositeOperation = oprtns[i];
            //设置新图形（红色圆形）
            context.beginPath();
            context.fillStyle = &quot;red&quot;;
            context.arc(60, 60, 30, 0, Math.PI * 2, false);
            context.fill();
       }, 1000);

     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822418.png" alt="Mou"><br>给图形绘制阴影</p>
<p>context.shadowOffsetX :阴影的横向位移量（默认值为0）</p>
<p>context.shadowOffsetY :阴影的纵向位移量（默认值为0）</p>
<p>context.shadowColor :阴影的颜色</p>
<p>context.shadowBlur :阴影的模糊范围（值越大越模糊）</p>
<p>先来个简单的例子</p>
<pre><code>View Code 
     function draw27(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&apos;2d&apos;);
         context.shadowOffsetX = 10;
         context.shadowOffsetY = 10;
         context.shadowColor = &apos;rgba(100,100,100,0.5)&apos;;
         context.shadowBlur = 1.5;
         context.fillStyle = &apos;rgba(255,0,0,0.5)&apos;;
         context.fillRect(100, 100, 200, 100);
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822419.png" alt="Mou"><br>再来个书本上的五角星的例子</p>
<pre><code>View Code 
     function create5Star(context) {
         var n = 0;
         var dx = 100;
         var dy = 0;

         var s = 50;
         //创建路径
         context.beginPath();
         context.fillStyle = &apos;rgba(255,0,0,0.5)&apos;;
         var x = Math.sin(0);
         var y = Math.cos(0);
         var dig = Math.PI / 5 * 4;
         for (var i = 0; i &lt; 5; i++) {
             var x = Math.sin(i * dig);
             var y = Math.cos(i * dig);
             context.lineTo(dx + x * s, dy + y * s);

         }
         context.closePath();

     }

     function draw11(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         context.fillStyle = &quot;#EEEEFF&quot;;
         context.fillRect(0, 0, 400, 300);

         context.shadowOffsetX = 10;
         context.shadowOffsetY = 10;
         context.shadowColor = &apos;rgba(100,100,100,0.5)&apos;;
         context.shadowBlur =5;
         //图形绘制
         context.translate(0, 50);
         for (var i = 0; i &lt; 3; i++) {
             context.translate(50, 50);
             create5Star(context);
             context.fill();
         }
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822420.png" alt="Mou"> </p>
<h3 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h3><p>绘图：context.drawImage</p>
<p>图像平铺：context.createPattern(image,type)</p>
<p>图像裁剪：context.clip()</p>
<p>像素处理：var imagedata=context.getImageData(sx,sy,sw,sh)</p>
<p>绘图 context.drawImage</p>
<p>context.drawImage(image,x,y)</p>
<p>image:Image对象var img=new Image(); img.src=”url(…)”;</p>
<p>x:绘制图像的x坐标</p>
<p>y:绘制图像的y坐标</p>
<p>context.drawImage(image,x,y,w,h)</p>
<p>image:Image对象var img=new Image(); img.src=”url(…)”;</p>
<p>x:绘制图像的x坐标</p>
<p>y:绘制图像的y坐标</p>
<p>w:绘制图像的宽度</p>
<p>h:绘制图像的高度</p>
<p>context.drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh):选取图像的一部分矩形区域进行绘制</p>
<p>image:Image对象var img=new Image(); img.src=”url(…)”;</p>
<p>sx：图像上的x坐标</p>
<p>sy：图像上的y坐标</p>
<p>sw：矩形区域的宽度</p>
<p>sh：矩形区域的高度</p>
<p>dx：画在canvas的x坐标</p>
<p>dy：画在canvas的y坐标</p>
<p>dw：画出来的宽度</p>
<p>dh：画出来的高度</p>
<p>最后一个方法可能比较拗，还是上图吧<br><img src="http://www.uml.org.cn/html/images/20120822421.png" alt="Mou"> </p>
<pre><code>   View Code 
    //drawImage(image,x,y)
    function draw28(id) {

    var image = new Image();

    image.src = &quot;Image/html5.jpg&quot;;
    var canvas = document.getElementById(id);

    if (canvas == null)
        return false;
    var context = canvas.getContext(&quot;2d&quot;);
    context.fillStyle = &quot;#EEEEFF&quot;;

    context.fillRect(0, 0, 400, 300);
    image.onload = function () {
        context.drawImage(image,0,0);
    }
}

//drawImage(image,x,y,w,h)
function draw12(id) {

    var image = new Image();

    image.src = &quot;Image/html5.jpg&quot;;
    var canvas = document.getElementById(id);

    if (canvas == null)
        return false;
    var context = canvas.getContext(&quot;2d&quot;);
    context.fillStyle = &quot;#EEEEFF&quot;;

    context.fillRect(0, 0, 400, 300);
    image.onload = function () {
        context.drawImage(image, 50, 50, 300, 200);
    }
}

//drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh)
function draw13(id){
    var image = new Image();
    image.src = &quot;Image/html5.jpg&quot;;
    var canvas = document.getElementById(id);

    if (canvas == null)
        return false;
    var context = canvas.getContext(&quot;2d&quot;);
    context.fillStyle = &quot;#EEEEFF&quot;;

    context.fillRect(0, 0, 400, 300);
    image.onload = function () {
        context.drawImage(image, 100, 100, 200, 150,50,50,300,200);//这里取的是实际尺寸
    }
} 
</code></pre><p>三个方法的运行结果如下：<br><img src="http://www.uml.org.cn/html/images/20120822422.png" alt="Mou"><br><img src="http://www.uml.org.cn/html/images/20120822423.png" alt="Mou"><br><img src="http://www.uml.org.cn/html/images/20120822424.png" alt="Mou"> </p>
<h3 id="图像平铺"><a href="#图像平铺" class="headerlink" title="图像平铺"></a>图像平铺</h3><p>context.createPattern(image,type)</p>
<p>type:</p>
<p>no-repeat:不平铺</p>
<p>repeat-x:横方向平铺</p>
<p>repeat-y:纵方向平铺</p>
<p>repeat:全方向平铺</p>
<p>类似图形组合，给出动态的切换平铺类型代码</p>
<pre><code>View Code 
     function draw14(id) {
         //传统的平铺是用for循环来处理的，现在直接调用接口
         var image = new Image();
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         var type = [&quot;no-repeat&quot;, &quot;repeat-x&quot;, &quot;repeat-y&quot;, &quot;repeat&quot;];
         var i = 0;
         image.src = &quot;Image/wordslogo.jpg&quot;;
         image.onload = function () {
             var interval = setInterval(function () {
                 //每次转换平铺类型清空
                 context.clearRect(0, 0, 400, 300);
                 if (i &gt;= 4) {
                     i = 0;
                 }
                 var ptrn = context.createPattern(image, type[i]);
                 context.fillStyle = ptrn;
                 context.fillRect(0, 0, 400, 300);
                 i++;
             }, 1000);
         };
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822424.png" alt="Mou"> </p>
<h3 id="图像裁剪："><a href="#图像裁剪：" class="headerlink" title="图像裁剪："></a>图像裁剪：</h3><p>context.clip()</p>
<p>context.clip()只绘制封闭路径区域内的图像，不绘制路径外部图像，用的时候</p>
<p>先创建裁剪区域</p>
<p>再绘制图像（之后绘制的图形都会采用这个裁剪区域，要取消这个裁剪区域就需要用到保存恢复状态，下面有讲）</p>
<p>给出圆形和星形的裁剪代码</p>
<pre><code>View Code 
     //图像裁剪
     function draw15(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         context.fillStyle = &quot;black&quot;;
         context.fillRect(0, 0, 400, 300);
         image = new Image();
         image.onload = function () {
             drawImg(context,image);
         }
         image.src = &quot;Image/html5.jpg&quot;
     }

     function drawImg(context, image) {
         //圆形裁剪区
         //createCircleClip(context)
         //星形裁剪区
         create5StarClip(context);
         context.drawImage(image,0,0);
     }

     function createCircleClip(context) {
         context.beginPath();
         context.arc(200, 150, 100, 0, Math.PI * 2, true);
         context.closePath();
         context.clip();
     }

     function create5StarClip(context) {
         var n = 0;
         var dx = 200;
         var dy = 135;
         var s = 150;
         context.beginPath();
         var x = Math.sin(0);
         var y = Math.cos(0);
         var dig = Math.PI / 5 * 4;
         for (var i = 0; i &lt; 5; i++) {
             var x = Math.sin(i * dig);
             var y = Math.cos(i * dig);
             context.lineTo(dx + x * s, dy + y * s);
         }
         context.closePath();
         context.clip();
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822426.png" alt="Mou"><br><img src="http://www.uml.org.cn/html/images/20120822427.png" alt="Mou"> </p>
<h3 id="像素处理："><a href="#像素处理：" class="headerlink" title="像素处理："></a>像素处理：</h3><p>获取像素颜色数组： var imagedata=context.getImageData(sx,sy,sw,sh)</p>
<p>sx:cavas的x轴坐标点</p>
<p>sy:canvas的y轴坐标点</p>
<p>sw:距离x的宽度</p>
<p>sh:距离y的高度</p>
<p>可以利用context.getImageData返回的一个像素颜色数组，顺序是所取像素范围的从左到右，从上到下，数组的元素是（所有图形，包括图片，和绘制的图形）每个像素的rgba</p>
<p>[r1,g1,b1,a1,r2,g2,b2,a2…]</p>
<p>设置像素颜色：context.putImageData(imagedata,dx,dy,dirtyX,dirtyY,dirtyWidth,dirtyHeight)</p>
<p>对imagedata数组中的各个像素的r、g、b、a值进行修改，再调用putImageData方法进行绘制</p>
<p>imagedata:修改后的imagedata</p>
<p>dx:重绘图像的起点横坐标（重绘的起点和原来的图像一致的话就会把原来的图形覆盖掉，看起来就像是原来的图像变成现在的图像一样）</p>
<p>dy:重绘图像的起点纵坐标</p>
<p>//以下可选参数，设置重绘的矩形范围，如果缺省，默认会重绘所有的imegedata</p>
<p>dirtyX:矩形左上角x轴坐标</p>
<p>dirtyY:矩形左上角y轴坐标</p>
<p>dirtyWidth:矩形长度</p>
<p>dirtyHeight:矩形高度</p>
<pre><code>View Code 
     function draw16(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         context.fillStyle = &apos;red&apos;
         //在右下角画一个正方形
         context.fillRect(250,250,150,50);
         var image = new Image();
         image.src = &quot;Image/html5.jpg&quot;;

         image.onload = function () {
             //在左上角画一幅图片
             context.drawImage(image, 0, 0,200,200);

             //实验证明imagedata取的是canvas所在范围画的图形，不止是图片
             //不会取该区域内是空白的canvas的像素
             var imagedata = context.getImageData(0, 0, 400, 300);

             //修改imagedata
             for (var i = 0, n = imagedata.data.length; i &lt; n; i += 4) {

                 imagedata.data[i + 0] = 255 - imagedata.data[i + 0]; //red;
                 imagedata.data[i + 1] = 255 - imagedata.data[i + 1]; //green
                 imagedata.data[i + 2] = 255 - imagedata.data[i + 2]; //blue
                 //imagedata.data[i + 3] = 255 - imagedata.data[i + 3]; //a
             }
             context.putImageData(imagedata, 0, 0);
         }
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822428.png" alt="Mou"> </p>
<h3 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h3><p>填充文字：context.fillText(text,x,y)</p>
<p>绘制文字轮廓 context.strokeText(text,x,y)</p>
<p>text:要绘制的文字</p>
<p>x:文字起点的x坐标轴</p>
<p>y:文字起点的y坐标轴</p>
<p>context.font:设置字体样式</p>
<p>context.textAlign:水平对齐方式</p>
<p>start、end、right、center</p>
<p>context.textBaseline:垂直对齐方式</p>
<p>top、hanging、middle、alphabetic、ideographic、bottom</p>
<p>var length=context.measureText(text):计算字体长度(px)那么能不能计算高度啊，很遗憾，不能</p>
<pre><code>View Code 
     function draw17(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         context.fillStyle = &quot;#EEEEFF&quot;;
         context.fillRect(0,0,400,300);
         context.fillStyle = &quot;#00f&quot;;
         context.font = &quot;italic 30px sans-serif&quot;;
         context.textBaseline = &apos;top&apos;;
         //填充字符串
         var txt=&quot;fill示例文字&quot;
         context.fillText(txt, 0, 0);
         var length=context.measureText(txt);
         context.fillText(&quot;长&quot; + length.width + &quot;px&quot;, 0, 50);
         context.font = &quot;bolid 30px sans-serif&quot;;
         txt = &quot;stroke示例文字&quot;;
         length = context.measureText(txt);
         context.strokeText(txt,0,100);
         context.fillText(&quot;长&quot; + length.width + &quot;px&quot;, 0, 150);
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822429.png" alt="Mou"> </p>
<h3 id="保存和恢复状态"><a href="#保存和恢复状态" class="headerlink" title="保存和恢复状态"></a>保存和恢复状态</h3><p>保存：context.save()</p>
<p>恢复：context.restore()</p>
<p>在上面的裁剪图片提过，一旦设定了裁剪区域，后来绘制的图形都只显示裁剪区域内的内容，要“取消”这个裁剪区域才能正常绘制其他图形，其实这个“取消”是利用save（）方法和restore（）方法来实现的。</p>
<p>context.save()：调用该方法，会保存当前context的状态、属性（把他理解成游戏存档）</p>
<p>context.restore():调用该方法就能恢复到save时候context的状态、属性（游戏回档）</p>
<pre><code>View Code 
function draw18(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         context.fillStyle = &quot;red&quot;;
         context.save(); //保存了当前context的状态
         context.fillStyle = &quot;black&quot;;
         context.fillRect(0, 0, 100, 100);
         context.restore();//恢复到刚刚保存的状态
         context.fillRect(0,120,100,100);
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822430.png" alt="Mou"> </p>
<h3 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h3><p>canvas.toDataURL(MIME)</p>
<p>在canvas中绘出的图片只是canvas标签而已，并非是真正的图片，是不能右键，另存为的，我们可以利用canvas.toDataURL()这个方法把canvas绘制的图形生成一幅图片，生成图片后，就能对图片进行相应的操作了。</p>
<pre><code>View Code 
     function draw19(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         context.fillStyle = &quot;rgb(0,0,225)&quot;;
         context.fillRect(0, 0, canvas.width, canvas.height);
         context.fillStyle = &quot;rgb(255,255,0)&quot;;
         context.fillRect(10, 20, 50, 50);
         //把图像保存到新的窗口
         var w=window.open(canvas.toDataURL(&quot;image/jpeg&quot;),&quot;smallwin&quot;,&quot;width=400,height=350&quot;);
    } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822431.png" alt="Mou">        </p>
<h3 id="结合setInterval制作动画"><a href="#结合setInterval制作动画" class="headerlink" title="结合setInterval制作动画"></a>结合setInterval制作动画</h3><p>基本原理就是定时清除整个canvas重新绘制，下面给出“我弹、我弹、我弹弹弹”的代码 （额、名字而已）</p>
<p>小矩形在矩形区域移动，碰到矩形区域的边缘反弹</p>
<pre><code>View Code 
    function draw20(id) {
        var canvas = document.getElementById(id);
        if (canvas == null)
            return false;
        var context = canvas.getContext(&quot;2d&quot;);

        var interal = setInterval(function () {
            move(context);
        }, 1);
    }

    var x = 100;//矩形开始坐标
    var y = 100;//矩形结束坐标
    var mx = 0;//0右1左
    var my = 0; //0下1上
    var ml = 1;//每次移动长度
    var w = 20;//矩形宽度
    var h = 20;//矩形高度
    var cw = 400;//canvas宽度
    var ch = 300; //canvas高度


    function move(context) {
        context.clearRect(0, 0, 400, 300);
        context.fillStyle = &quot;#EEEEFF&quot;;
        context.fillRect(0, 0, 400, 300);
        context.fillStyle = &quot;red&quot;;
        context.fillRect(x, y, w, h);       
        if (mx == 0) {
            x = x + ml;
            if (x &gt;= cw-w) {
                mx = 1;
            }
        }
        else {
            x = x - ml;
            if (x &lt;= 0) {
                mx = 0;
            }
        }
        if (my == 0) {
            y = y + ml;
            if (y &gt;= ch-h) {
                my = 1;
            }
        }
        else {
            y = y - ml;
            if (y &lt;= 0) {
                my = 0;
            }
        }

    } 
</code></pre><p> <img src="http://www.uml.org.cn/html/images/20120822432.png" alt="Mou">  </p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>历时一天半，本来以为可以玩转的，写下来才发现要玩转canvas还需要很多的实践，这个道理应该是适用所有的技术的，做人啊，就得谦虚点。本文如有错误，请及时留言给我纠正，希望能给正在学canvas绘图的童鞋有所帮助</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/16/canvas画图/" class="archive-article-date">
  	<time datetime="2016-11-16T12:00:25.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-16</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="玩转html5-canvas画图" data-title="canvas画图" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"qianjenbo"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-Vue-js" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/15/Vue-js/">Vue.js</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="介绍-一"><a href="#介绍-一" class="headerlink" title="介绍(一)"></a>介绍(一)</h1><h2 id="Vue-js-是什么"><a href="#Vue-js-是什么" class="headerlink" title="Vue.js 是什么"></a>Vue.js 是什么</h2><hr>
<p>Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue </p>
<p>采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整</p>
<p>合。另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。</p>
<p>Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p>
<p>如果你是有经验的前端开发者，想知道 Vue.js 与其它库/框架的区别，查看对比其它框架。</p>
<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><pre><code>官方指南假设你已有HTML、CSS和JavaScript中级前端知识。如果你是全新的前端开发者，它可能不是最好    的想法，将一个框架作为你的第一步-最好掌握基本知识再来！其他框架以前的经验是有帮助的，但不是必需    的。
</code></pre><p>尝试 Vue.js 最简单的方法是使用 <a href="https://jsfiddle.net/chrisvfritz/50wL7mdz/" target="_blank" rel="external">JSFiddle Hello World</a> 例子。你可以在浏览器新标签页中打开它，跟着我们学习一些基础示例。或者你也可以创建一个本地的 .html 文件，然后引入 Vue:</p>
<pre><code>&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;
</code></pre><p>你可以查看<a href="http://cn.vuejs.org/v2/guide/installation.html" target="_blank" rel="external">安装指南</a>来了解其他安装 Vue 的选项。请注意我们不推荐新手直接使用 vue-cli，尤其是对 Node.js 构建工具不够了解的同学。</p>
<h2 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h2><hr>
<p>Vue.js 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统：</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
  {{ message }}
    &lt;/div&gt;
    var app = new Vue({
      el: &apos;#app&apos;,
      data: {
    message: &apos;Hello Vue!&apos;
  }
    })
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hello Vue！</div></pre></td></tr></table></figure>
<p>我们已经生成了我们的第一个 Vue 应用！看起来这跟单单渲染一个字符串模板非常类似，但是 Vue.js 在背后做了大量工作。现在数据和 DOM 已经被绑定在一起，所有的元素都是响应式的。我们如何知道？打开你的浏览器的控制台，并修改 <code>app.message</code> ，你将看到上例相应地更新。</p>
<p>除了绑定插入的文本内容，我们还可以采用这样的方式绑定 DOM 元素属性：</p>
<pre><code>&lt;div id=&quot;app-2&quot;&gt;
  &lt;span v-bind:title=&quot;message&quot;&gt;
Hover your mouse over me for a few seconds to see my dynamically bound title!
  &lt;/span&gt;
&lt;/div&gt;
var app2 = new Vue({
  el: &apos;#app-2&apos;,
  data: {
message: &apos;You loaded this page on &apos; + new Date()
  }
})
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hover your mouse over me for a few seconds to see my dynamically bound title!</div></pre></td></tr></table></figure>
<p>这里我们遇到点新东西。你看到的 <code>v-bind</code> 属性被称为指令。指令带有前缀 <code>v-</code>，以表示它们是 Vue.js 提供的特殊属性。可能你已经猜到了，它们会在渲染过的 DOM 上应用特殊的响应式行为。这个指令的简单含义是说：将这个元素节点的 <code>title</code>属性和 Vue 实例的 <code>message</code> 属性绑定到一起。</p>
<p>你再次打开浏览器的控制台输入 <code>app2.message = &#39;some new message&#39;</code>，你就会再一次看到这个绑定了<code>title</code>属性的HTML已经进行了更新。</p>
<h2 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h2><hr>
<p>控制切换一个元素的显示也相当简单：</p>
<pre><code>&lt;div id=&quot;app-3&quot;&gt;
  &lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;
&lt;/div&gt;
var app3 = new Vue({
  el: &apos;#app-3&apos;,
  data: {
seen: true
  }
})
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Now you see me</div></pre></td></tr></table></figure>
<p>继续在控制台设置 <code>app3.seen = false</code>，你会发现 “Now you see me” 消失了。</p>
<p>这个例子演示了我们不仅可以绑定 DOM 文本到数据，也可以绑定 DOM 结构到数据。而且，Vue.js 也提供一个强大的过渡效果系统，可以在 Vue 插入/删除元素时自动应用<code>过渡效果</code>。</p>
<p>也有一些其它指令，每个都有特殊的功能。例如， <code>v-for</code> 指令可以绑定数据到数据来渲染一个列表：</p>
<pre><code>&lt;div id=&quot;app-4&quot;&gt;
  &lt;ol&gt;
    &lt;li v-for=&quot;todo in todos&quot;&gt;
  {{ todo.text }}
&lt;/li&gt;
  &lt;/ol&gt;
    &lt;/div&gt;
    var app4 = new Vue({
      el: &apos;#app-4&apos;,
      data: {
    todos: [
      { text: &apos;Learn JavaScript&apos; },
      { text: &apos;Learn Vue&apos; },
      { text: &apos;Build something awesome&apos; }
        ]
      }
    })
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Learn JavaScript</div><div class="line">Learn Vue</div><div class="line">Build something awesome</div></pre></td></tr></table></figure>
<p>在控制台里，输入 <code>app4.todos.push({ text: &#39;New item&#39; })</code>。你会发现列表中多了一栏新内容。</p>
<h2 id="处理用户输入"><a href="#处理用户输入" class="headerlink" title="处理用户输入"></a>处理用户输入</h2><hr>
<p>为了让用户和你的应用进行互动，我们可以用 v-on 指令绑定一个监听事件用于调用我们 Vue 实例中定义的方法：</p>
<pre><code>&lt;div id=&quot;app-5&quot;&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  &lt;button v-on:click=&quot;reverseMessage&quot;&gt;Reverse Message&lt;/button&gt;
&lt;/div&gt;
    var app5 = new Vue({
     el: &apos;#app-5&apos;,
      data: {
        message: &apos;Hello Vue.js!&apos;
      },
      methods: {
        reverseMessage: function () {
          this.message = this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)
    }
      }
})
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Hello Vue.js!</div><div class="line"></div><div class="line">Reverse Message</div></pre></td></tr></table></figure>
<p>在 <code>reverseMessage</code> 方法中，我们在没有接触 DOM 的情况下更新了应用的状态 - 所有的 DOM 操作都由 Vue 来处理，你写的代码只需要关注基本逻辑。</p>
<p>Vue 也提供了<code>v-model</code> 指令，它使得在表单输入和应用状态中做双向数据绑定变得非常轻巧。</p>
<pre><code>&lt;div id=&quot;app-6&quot;&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  &lt;input v-model=&quot;message&quot;&gt;
&lt;/div&gt;
var app6 = new Vue({
  el: &apos;#app-6&apos;,
  data: {
    message: &apos;Hello Vue!&apos;
  }
})
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Hello Vue!</div><div class="line"></div><div class="line">Hello Vue!</div></pre></td></tr></table></figure>
<h2 id="用组件构建（应用）"><a href="#用组件构建（应用）" class="headerlink" title="用组件构建（应用）"></a>用组件构建（应用）</h2><hr>
<p>组件系统是 Vue.js 另一个重要概念，因为它提供了一种抽象，让我们可以用独立可复用的小组件来构建大型应用。如果我们考虑到这点，几乎任意类型的应用的界面都可以抽象为一个组件树：<br><img src="http://cn.vuejs.org/images/components.png" alt="Mou"></p>
<p>在 Vue 里，一个组件实质上是一个拥有预定义选项的一个 Vue 实例：</p>
<pre><code>// Define a new component called todo-item
Vue.component(&apos;todo-item&apos;, {
  template: &apos;&lt;li&gt;This is a todo&lt;/li&gt;&apos;
})
</code></pre><p>现在你可以另一个组件模板中写入它：</p>
<pre><code>&lt;ul&gt;
  &lt;!-- Create an instance of the todo-item component --&gt;
  &lt;todo-item&gt;&lt;/todo-item&gt;
&lt;/ul&gt;
</code></pre><p>但是这样会为每个 todo 渲染同样的文本，这看起来并不是很酷。我们应该将数据从父作用域传到子组件。让我们来修改一下组件的定义，使得它能够接受一个 prop 字段：</p>
<pre><code>Vue.component(&apos;todo-item&apos;, {
  // The todo-item component now accepts a
  // &quot;prop&quot;, which is like a custom attribute.
  // This prop is called todo.
  props: [&apos;todo&apos;],
  template: &apos;&lt;li&gt;{{ todo.text }}&lt;/li&gt;&apos;
})
</code></pre><p>现在，我们可以使用 v-bind 指令将 todo 传到每一个重复的组件中：</p>
<pre><code>&lt;div id=&quot;app-7&quot;&gt;
  &lt;ol&gt;
&lt;!-- Now we provide each todo-item with the todo object    --&gt;
&lt;!-- it&apos;s representing, so that its content can be dynamic --&gt;
&lt;todo-item v-for=&quot;item in groceryList&quot; v-bind:todo=&quot;item&quot;&gt;&lt;/todo-item&gt;
  &lt;/ol&gt;
&lt;/div&gt;
Vue.component(&apos;todo-item&apos;, {
  props: [&apos;todo&apos;],
  template: &apos;&lt;li&gt;{{ todo.text }}&lt;/li&gt;&apos;
})
var app7 = new Vue({
  el: &apos;#app-7&apos;,
  data: {
groceryList: [
  { text: &apos;Vegetables&apos; },
  { text: &apos;Cheese&apos; },
  { text: &apos;Whatever else humans are supposed to eat&apos; }
]
  }
})
</code></pre><p>1.Vegetables</p>
<p>2.Cheese</p>
<p>3.Whatever else humans are supposed to eat</p>
<p>这只是一个假设的例子，但是我们已经将应用分割成了两个更小的单元，子元素通过 <code>props</code> 接口实现了与父亲元素很好的解耦。我们现在可以在不影响到父应用的基础上，进一步为我们的 <code>todo</code> 组件改进更多复杂的模板和逻辑。</p>
<p>在一个大型应用中，为了使得开发过程可控，有必要将应用整体分割成一个个的组件。在<code>后面的教程</code>中我们将详述组件，不过这里有一个（假想）的例子，看看使用了组件的应用模板是什么样的：</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
  &lt;app-nav&gt;&lt;/app-nav&gt;
  &lt;app-view&gt;
    &lt;app-sidebar&gt;&lt;/app-sidebar&gt;
&lt;app-content&gt;&lt;/app-content&gt;
  &lt;/app-view&gt;
&lt;/div&gt;
</code></pre><h2 id="与自定义元素的关系"><a href="#与自定义元素的关系" class="headerlink" title="与自定义元素的关系"></a>与自定义元素的关系</h2><hr>
<p>你可能已经注意到 Vue.js 组件非常类似于自定义元素——它是<code>Web 组件规范</code>的一部分。实际上 Vue.js 的组件语法参考了该规范。例如 Vue 组件实现了 <code>Slot API</code> 与<code>is</code> 特性。但是，有几个关键的不同：</p>
<p>1.Web 组件规范仍然远未完成，并且没有浏览器实现。相比之下，Vue.js 组件不需要任何补丁，并且在所有支持的浏览器（IE9 及更高版本）之下表现一致。必要时，Vue.js 组件也可以放在原生自定义元素之内。</p>
<p>2.Vue.js 组件提供了原生自定义元素所不具备的一些重要功能，比如组件间的数据流，自定义事件系统，以及动态的、带特效的组件替换。</p>
<h2 id="准备好探索更广阔的世界了？"><a href="#准备好探索更广阔的世界了？" class="headerlink" title="准备好探索更广阔的世界了？"></a>准备好探索更广阔的世界了？</h2><hr>
<p>我们刚才简单介绍了 Vue.js 核心的一些最基本的特征 - 本指南的其余部分将用更详尽的篇幅去描述其他的一些高级特性，所以一定要阅读完所有的内容哦！</p>
<h4 id="原文：http-vuejs-org-guide-index-html"><a href="#原文：http-vuejs-org-guide-index-html" class="headerlink" title="原文：http://vuejs.org/guide/index.html"></a>原文：<a href="http://vuejs.org/guide/index.html" target="_blank" rel="external">http://vuejs.org/guide/index.html</a></h4>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/15/Vue-js/" class="archive-article-date">
  	<time datetime="2016-11-15T11:26:49.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-15</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-Vue-js" data-title="Vue.js" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"qianjenbo"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-FullPage-js" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="FullPage-js"><a href="#FullPage-js" class="headerlink" title="FullPage.js"></a>FullPage.js</h1><p>七牛最近改版了网站，弄成全屏滚动的特效，真的很炫，于是查看其源代码，发现了一个fullPage.js插件，于是百度了一下，还就是这个插件的作用，其实有很多网站都做了全屏滚动的特效，效果也很好看，今天就给大家说说fullPage.js的使用方法和设置。</p>
<p><img src="http://www.uedsc.com/wp-content/uploads/2014/06/77.png" alt="Mou"></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>fullPage.js是一个基于jQuery的全屏滚动插件，它能够很方便、很轻松的制作出全屏网站。</p>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul>
<li>支持鼠标滚动</li>
</ul>
<ul>
<li>支持前进后退和键盘控制</li>
</ul>
<ul>
<li>多个回调函数</li>
</ul>
<ul>
<li>支持手机、平板触摸事件</li>
</ul>
<ul>
<li>支持 CSS3 动画</li>
</ul>
<ul>
<li>支持窗口缩放</li>
</ul>
<ul>
<li>窗口缩放时自动调整</li>
</ul>
<ul>
<li>可设置滚动宽度、背景颜色、滚动速度、循环选项、回调、文本对齐方式等等</li>
</ul>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>fullPage.js 支持 IE8+ 及其他现代浏览器。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h5 id="1、引入文件"><a href="#1、引入文件" class="headerlink" title="1、引入文件"></a>1、引入文件</h5><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css/jquery.fullPage.css&quot;&gt;
&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/jquery-ui.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/jquery.fullPage.js&quot;&gt;&lt;/script&gt;
</code></pre><h4 id="2、HTML"><a href="#2、HTML" class="headerlink" title="2、HTML"></a>2、HTML</h4><pre><code>&lt;div id=&quot;fullpage&quot;&gt;
&lt;div class=&quot;section&quot;&gt;第一屏&lt;/div&gt;
&lt;div class=&quot;section&quot;&gt;第二屏&lt;/div&gt;
&lt;div class=&quot;section&quot;&gt;
    &lt;div class=&quot;slide&quot;&gt;第三屏的第一屏&lt;/div&gt;
    &lt;div class=&quot;slide&quot;&gt;第三屏的第二屏&lt;/div&gt;
    &lt;div class=&quot;slide&quot;&gt;第三屏的第三屏&lt;/div&gt;
    &lt;div class=&quot;slide&quot;&gt;第三屏的第四屏&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot;&gt;第四屏&lt;/div&gt;
&lt;/div&gt;
</code></pre><h4 id="3、JavaScript"><a href="#3、JavaScript" class="headerlink" title="3、JavaScript"></a>3、JavaScript</h4><pre><code>$(function(){
$(&apos;#fullpage&apos;).fullpage({
    &apos;verticalCentered&apos;: false,
    &apos;css3&apos;: true,
    &apos;sectionsColor&apos;: [&apos;#254875&apos;, &apos;#00FF00&apos;, &apos;#254587&apos;, &apos;#695684&apos;],
    anchors: [&apos;page1&apos;, &apos;page2&apos;, &apos;page3&apos;, &apos;page4&apos;],
    &apos;navigation&apos;: true,
    &apos;navigationPosition&apos;: &apos;right&apos;,
    &apos;navigationTooltips&apos;: [&apos;fullPage.js&apos;, &apos;Powerful&apos;, &apos;Amazing&apos;, &apos;Simple&apos;]
})
})
</code></pre><p>经测试最好至少有 anchors 这个参数，否则在火狐浏览器中，第一次滚动会直接滚到底部，点击这里查看上面代码的示例：<a href="http://www.uedsc.com/wp-content/uploads/2015/02/fullpage-demo/" target="_blank" rel="external">@A Fullpage简单示例。</a></p>
<h2 id="可选配置"><a href="#可选配置" class="headerlink" title="可选配置"></a>可选配置</h2><h4 id="1、选项"><a href="#1、选项" class="headerlink" title="1、选项"></a>1、选项</h4><pre><code>选项            类型            默认值            说明

verticalCentered    字符串    true    内容是否垂直居中

resize    布尔值    false    字体是否随着窗口缩放而缩放

slidesColor    函数    无    设置背景颜色

anchors    数组    无    定义锚链接

scrollingSpeed    整数    700    滚动速度，单位为毫秒

easing    字符串    easeInQuart    滚动动画方式

menu    布尔值    false    绑定菜单，设定的相关属性与 anchors 的值对应后，菜单可以控制滚动

navigation    布尔值    false    是否显示项目导航

navigationPosition    字符串    right    项目导航的位置，可选 left 或 right

navigationColor    字符串    #000    项目导航的颜色

navigationTooltips    数组    空    项目导航的 tip

slidesNavigation    布尔值    false    是否显示左右滑块的项目导航

slidesNavPosition    字符串    bottom    左右滑块的项目导航的位置，可选 top 或 bottom

controlArrowColor    字符串    #fff    左右滑块的箭头的背景颜色

loopBottom    布尔值    false    滚动到最底部后是否滚回顶部

loopTop    布尔值    false    滚动到最顶部后是否滚底部

loopHorizontal    布尔值    true    左右滑块是否循环滑动

autoScrolling    布尔值    true    是否使用插件的滚动方式，如果选择 false，则会出现浏览器自        带的滚动条
scrollOverflow    布尔值    false    内容超过满屏后是否显示滚动条

css3    布尔值    false    是否使用 CSS3 transforms 滚动

paddingTop    字符串    0    与顶部的距离

paddingBottom    字符串    0    与底部距离

fixedElements    字符串    无    

normalScrollElements        无    

keyboardScrolling    布尔值    true    是否使用键盘方向键导航

touchSensitivity    整数    5    

continuousVertical    布尔值    false    是否循环滚动，与 loopTop 及 loopBottom 不兼容

animateAnchor    布尔值    true    

normalScrollElementTouchThreshold    整数    5    
</code></pre><h4 id="2、方法"><a href="#2、方法" class="headerlink" title="2、方法"></a>2、方法</h4><pre><code>名称                            说明

moveSectionUp()                向上滚动

moveSectionDown()            向下滚动

moveTo(section, slide)        滚动到

moveSlideRight()            slide 向右滚动

moveSlideLeft()                slide 向左滚动

setAutoScrolling()            设置页面滚动方式，设置为 true 时自动滚动

setAllowScrolling()            添加或删除鼠标滚轮/触控板控制

setKeyboardScrolling()        添加或删除键盘方向键控制

setScrollingSpeed()            定义以毫秒为单位的滚动速度
</code></pre><h3 id="3、回调函数"><a href="#3、回调函数" class="headerlink" title="3、回调函数"></a>3、回调函数</h3><pre><code>名称                        说明

afterLoad            滚动到某一屏后的回调函数，接收 anchorLink 和 index 两个参数

                        anchorLink是锚链接的名称，index 是序号，从1开始计算

onLeave                滚动前的回调函数，接收 index、nextIndex 和 direction 3个参数：

index                 是离开的“页面”的序号，从1开始计算；

nextIndex            是滚动到的“页面”的序号，从1开始计算；

direction             判断往上滚动还是往下滚动，值是 up 或 down。

afterRender            页面结构生成后的回调函数，或者说页面初始化完成后的回调函数

afterSlideLoad        滚动到某一水平滑块后的回调函数，与 afterLoad 类似，接收anchorLink、
                    index、slideIndex、direction 4个参数

onSlideLeave        某一水平滑块滚动前的回调函数，与 onLeave 类似，接anchorLinkindex、
                    slideIndex、direction 4个参数
</code></pre><h2 id="自定义Section高度"><a href="#自定义Section高度" class="headerlink" title="自定义Section高度"></a>自定义Section高度</h2><p>很多用户留言说无法自定义底部Footer的高度，我 也查阅了很多资料，都没有发现方法，但是无意间看到一个Fullpage的示例，实现自定义底部高度的方法，而且是不算在滑动的Section里面，在需 要自定义高度的DIV里面，只需要给Section添加.fp-auto-height类就可以实现自定义高度。</p>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul>
<li><p>官网地址：<a href="http://www.expressjs.com.cn/" target="_blank" rel="external">@A http://www.expressjs.com.cn/</a></p>
<p>jQuery无法加载导致页面失效</p>
</li>
<li><p>问说网Fullpage官网离线版：<a href="fullPage.js 官网">@A fullPage.js 官网</a></p>
</li>
<li><p>GitHub 地址：<a href="https://github.com/alvarotrigo/fullPage.js" target="_blank" rel="external">@A https://github.com/alvarotrigo/fullPage.js</a></p>
</li>
<li><p>问说网下载地址：<a href="http://static.uedsc.com/fullPage.js-master.zip" target="_blank" rel="external">@A http://static.uedsc.com/fullPage.js-master.zip</a><br>这个不是最版本，可能有些细节无法实现，请前往Fullpage的Github地址下载最新版本。</p>
</li>
</ul>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/15/FullPage-js/" class="archive-article-date">
  	<time datetime="2016-11-15T09:25:21.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-15</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-FullPage-js" data-title="" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"qianjenbo"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-Express" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><h2 id="基于-Node-js-平台，快速、开放、极简的-web-开发框架。"><a href="#基于-Node-js-平台，快速、开放、极简的-web-开发框架。" class="headerlink" title="基于 Node.js 平台，快速、开放、极简的 web 开发框架。"></a>基于 Node.js 平台，快速、开放、极简的 web 开发框架。</h2><pre><code>$ npm install express --save
</code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先假定你已经安装了 Node.js，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。</p>
<pre><code>$ mkdir myapp
$ cd myapp
</code></pre><p>通过 npm init 命令为你的应用创建一个 package.json 文件。 欲了解 package.json 是如何起作用的，请参考 Specifics of npm’s package.json handling。</p>
<pre><code>$ npm init
</code></pre><p>此命令将要求你输入几个参数，例如此应用的名称和版本。 你可以直接按“回车”键接受默认设置即可，下面这个除外：</p>
<pre><code>entry point: (index.js)
</code></pre><p>键入 app.js 或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的 index.js 文件名，只需按“回车”键即可。</p>
<p>接下来安装 Express 并将其保存到依赖列表中：</p>
<pre><code>$ npm install express --save
</code></pre><p>如果只是临时安装 Express，不想将它添加到依赖列表中，只需略去 –save 参数即可：</p>
<pre><code>$ npm install express
</code></pre><h3 id="Express网站：-A-http-www-expressjs-com-cn"><a href="#Express网站：-A-http-www-expressjs-com-cn" class="headerlink" title="Express网站：@A http://www.expressjs.com.cn/"></a>Express网站：<a href="http://www.expressjs.com.cn/" target="_blank" rel="external">@A http://www.expressjs.com.cn/</a></h3><h2 id="Express-应用生成器"><a href="#Express-应用生成器" class="headerlink" title="Express 应用生成器"></a>Express 应用生成器</h2><p>通过应用生成器工具 express 可以快速创建一个应用的骨架。</p>
<p>通过如下命令安装：</p>
<pre><code>$ npm install express-generator -g
</code></pre><p>-h 选项可以列出所有可用的命令行选项：</p>
<pre><code>$ express -h
</code></pre><p>  Usage: express [options] [dir]</p>
<p>  Options:</p>
<pre><code>-h, --help          output usage information
-V, --version       output the version number
-e, --ejs           add ejs engine support (defaults to jade)
    --hbs           add handlebars engine support
-H, --hogan         add hogan.js engine support
-c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
    --git           add .gitignore
-f, --force         force on non-empty directory
</code></pre><p>例如，下面的示例就是在当前工作目录下创建一个命名为 myapp 的应用。</p>
<pre><code>$ express myapp

       create : myapp
       create : myapp/package.json
       create : myapp/app.js
       create : myapp/public
       create : myapp/public/javascripts
       create : myapp/public/images
       create : myapp/routes
       create : myapp/routes/index.js
       create : myapp/routes/users.js
       create : myapp/public/stylesheets
       create : myapp/public/stylesheets/style.css
       create : myapp/views
       create : myapp/views/index.jade
       create : myapp/views/layout.jade
       create : myapp/views/error.jade
       create : myapp/bin
       create : myapp/bin/www
</code></pre><p>然后安装所有依赖包：</p>
<pre><code>$ cd myapp 
$ npm install
</code></pre><p>启动这个应用（MacOS 或 Linux 平台）：</p>
<pre><code>$ DEBUG=myapp npm start
</code></pre><p>Windows 平台使用如下命令：</p>
<pre><code>&gt; set DEBUG=myapp &amp; npm start
</code></pre><p>然后在浏览器中打开 <a href="http://localhost:3000/" target="_blank" rel="external">http://localhost:3000/</a> 网址就可以看到这个应用了。i</p>
<p>通过 Express 应用生成器创建的应用一般都有如下目录结构：</p>
<pre><code>    .
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
    │   ├── index.js
│   └── users.js
└── views
├── error.jade
├── index.jade
└── layout.jade

7 directories, 9 files
</code></pre><h1 id="一个简单的-Express-路由"><a href="#一个简单的-Express-路由" class="headerlink" title="一个简单的 Express 路由"></a>一个简单的 Express 路由</h1><p>这篇教程只是对 Express 路由做一个简单的介绍。路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问。</p>
<p>每一个路由都可以有一个或者多个处理器函数，当匹配到路由时，这个/些函数将被执行。</p>
<p>路由的定义由如下结构组成：app.METHOD(PATH, HANDLER)。其中，app 是一个 express 实例；METHOD 是某个 HTTP 请求方式中的一个；PATH 是服务器端的路径；HANDLER 是当路由匹配到时需要执行的函数。</p>
<p>下面的代码展示了几个路由实例：</p>
<pre><code>// 对网站首页的访问返回 &quot;Hello World!&quot; 字样
app.get(&apos;/&apos;, function (req, res) {
  res.send(&apos;Hello World!&apos;);
});

// 网站首页接受 POST 请求
app.post(&apos;/&apos;, function (req, res) {
  res.send(&apos;Got a POST request&apos;);
});

// /user 节点接受 PUT 请求
app.put(&apos;/user&apos;, function (req, res) {
      res.send(&apos;Got a PUT request at /user&apos;);
    });

// /user 节点接受 DELETE 请求
app.delete(&apos;/user&apos;, function (req, res) {
  res.send(&apos;Got a DELETE request at /user&apos;);
});
</code></pre><h1 id="Express-常见问题"><a href="#Express-常见问题" class="headerlink" title="Express 常见问题"></a>Express 常见问题</h1><p>我的应用该如何组织？<br>对于这个问题其实没有一个确定的答案。这要根据你的应用的规模和参与开发的团队来确定。为了尽可能灵活，Express 自身是并没有硬性要求应用结构是哪一种的。</p>
<p>根据你的需求，可以把路由和其他应用相关的业务逻辑存放在任意多个文件和任意目录中。下面推荐的实例或许对你能有一些启发：</p>
<ul>
<li>Route listings</li>
</ul>
<ul>
<li>Route map</li>
</ul>
<ul>
<li>MVC style controllers</li>
</ul>
<p>另外，这里还有一些第三方 Express 扩展简化了这种组织方式：</p>
<p>Resourceful routing</p>
<h3 id="如何定义模型（model）？"><a href="#如何定义模型（model）？" class="headerlink" title="如何定义模型（model）？"></a>如何定义模型（model）？</h3><p>Express自身并不感知数据库是否存在。数据库功能依赖于第三方 Node 模块提供的接口。</p>
<h3 id="如何验证用户？"><a href="#如何验证用户？" class="headerlink" title="如何验证用户？"></a>如何验证用户？</h3><p>这是另一个 Express 不涉及的领域。你可以使用任何验证方式。对于简单的用户名/密码验证方式，可以参考这个实例。</p>
<h3 id="Express-支持哪些模板引擎？"><a href="#Express-支持哪些模板引擎？" class="headerlink" title="Express 支持哪些模板引擎？"></a>Express 支持哪些模板引擎？</h3><p>Express 支持任何符合 (path, locals, callback) 接口规范的模板引擎。 为了统一模板引擎的接口和缓存功能，请参考 consolidate.js 项目。其他未提及的模板引擎也可能支持 Express 接口规范。</p>
<h3 id="如何处理-404-？"><a href="#如何处理-404-？" class="headerlink" title="如何处理 404 ？"></a>如何处理 404 ？</h3><p>在 Express 中，404 并不是一个错误（error）。因此，错误处理器中间件并不捕获 404。这是因为 404 只是意味着某些功能没有实现。也就是说，Express 执行了所有中间件、路由之后还是没有获取到任何输出。你所需要做的就是在其所有他中间件的后面添加一个处理 404 的中间件。如下：</p>
<pre><code>app.use(function(req, res, next) {
  res.status(404).send(&apos;Sorry cant find that!&apos;);
});
</code></pre><h3 id="如何设置一个错误处理器？"><a href="#如何设置一个错误处理器？" class="headerlink" title="如何设置一个错误处理器？"></a>如何设置一个错误处理器？</h3><p>错误处理器中间件的定义和其他中间件一样，唯一的区别是 4 个而不是 3 个参数，即 (err, req, res, next)：</p>
<pre><code>app.use(function(err, req, res, next) {
  console.error(err.stack);
  res.status(500).send(&apos;Something broke!&apos;);
});
</code></pre><h3 id="如何渲染纯-HTML-文件？"><a href="#如何渲染纯-HTML-文件？" class="headerlink" title="如何渲染纯 HTML 文件？"></a>如何渲染纯 HTML 文件？</h3><p>不需要！无需通过 res.render() 渲染 HTML。你可以通过 res.sendFile() 直接对外输出 HTML 文件。如果你需要对外提供的资源文件很多，可以使用 express.static() 中间件。</p>
<h3 id="Express网站：-A-http-www-expressjs-com-cn-1"><a href="#Express网站：-A-http-www-expressjs-com-cn-1" class="headerlink" title="Express网站：@A http://www.expressjs.com.cn/"></a>Express网站：<a href="http://www.expressjs.com.cn/" target="_blank" rel="external">@A http://www.expressjs.com.cn/</a></h3>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/15/Express/" class="archive-article-date">
  	<time datetime="2016-11-15T06:45:36.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-15</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-Express" data-title="" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"qianjenbo"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-布局教程：语法篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="Flex-布局教程：语法篇"><a href="#Flex-布局教程：语法篇" class="headerlink" title="Flex 布局教程：语法篇"></a>Flex 布局教程：语法篇</h1><h5 id="作者：-阮一峰"><a href="#作者：-阮一峰" class="headerlink" title="作者： 阮一峰"></a>作者： 阮一峰</h5><p>日期： 2015年7月10日</p>
<p>网页布局（layout）是CSS的一个重点应用。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071001.gif" alt="Mou"></p>
<p>布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071002.png" alt="Mou"></p>
<p>2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071003.jpg" alt="Mou"></p>
<p>Flex布局将成为未来布局的首选方案。本文介绍它的语法，下一篇文章给出常见布局的Flex写法。<br>以下内容主要参考了下面两篇文章：<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="external">@A Complete Guide to Flexbox</a> 和 <a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties" target="_blank" rel="external">@A Visual Guide to CSS3 Flexbox Properties</a>。</p>
<h1 id="一、Flex布局是什么？"><a href="#一、Flex布局是什么？" class="headerlink" title="一、Flex布局是什么？"></a>一、Flex布局是什么？</h1><hr>
<h3 id="Flex是Flexible-Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。"><a href="#Flex是Flexible-Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。" class="headerlink" title="Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。"></a>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</h3><p>###任何一个容器都可以指定为Flex布局。</p>
<pre><code>.box{
  display: flex;
}    
</code></pre><h3 id="行内元素也可以使用Flex布局。"><a href="#行内元素也可以使用Flex布局。" class="headerlink" title="行内元素也可以使用Flex布局。"></a>行内元素也可以使用Flex布局。</h3><pre><code>.box{
  display: inline-flex;
}
</code></pre><h3 id="Webkit内核的浏览器，必须加上-webkit前缀。"><a href="#Webkit内核的浏览器，必须加上-webkit前缀。" class="headerlink" title="Webkit内核的浏览器，必须加上-webkit前缀。"></a>Webkit内核的浏览器，必须加上-webkit前缀。</h3><pre><code>.box{
  display: -webkit-flex; /* Safari */
  display: flex;
}
</code></pre><h3 id="注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。"><a href="#注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。" class="headerlink" title="注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。"></a>注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</h3><h1 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h1><hr>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="Mou"></p>
<h3 id="容器默认存在两根轴：水平的主轴（main-axis）和垂直的交叉轴（cross-axis）。主轴的开始位置（与边框的交叉点）叫做main-start，结束位置叫做main-end；交叉轴的开始位置叫做cross-start，结束位置叫做cross-end。"><a href="#容器默认存在两根轴：水平的主轴（main-axis）和垂直的交叉轴（cross-axis）。主轴的开始位置（与边框的交叉点）叫做main-start，结束位置叫做main-end；交叉轴的开始位置叫做cross-start，结束位置叫做cross-end。" class="headerlink" title="容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。"></a>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</h3><h3 id="项目默认沿主轴排列。单个项目占据的主轴空间叫做main-size，占据的交叉轴空间叫做cross-size。"><a href="#项目默认沿主轴排列。单个项目占据的主轴空间叫做main-size，占据的交叉轴空间叫做cross-size。" class="headerlink" title="项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。"></a>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</h3><h1 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h1><hr>
<h4 id="以下6个属性设置在容器上。"><a href="#以下6个属性设置在容器上。" class="headerlink" title="以下6个属性设置在容器上。"></a>以下6个属性设置在容器上。</h4><ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content<h3 id="3-1-flex-direction属性"><a href="#3-1-flex-direction属性" class="headerlink" title="3.1 flex-direction属性"></a>3.1 flex-direction属性</h3></li>
</ul>
<hr>
<pre><code>.box {
  flex-direction: row | row-reverse | column | column-reverse;
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt="Mou"><br>它可能有4个值。</p>
<ul>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>
<h3 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性"></a>3.2 flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png" alt="Mou"></p>
<pre><code>.box{
      flex-wrap: nowrap | wrap | wrap-reverse;
}
</code></pre><p>它可能取三个值。</p>
<h4 id="（1）nowrap（默认）：不换行。"><a href="#（1）nowrap（默认）：不换行。" class="headerlink" title="（1）nowrap（默认）：不换行。"></a>（1）nowrap（默认）：不换行。</h4><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt="Mou"></p>
<h4 id="（2）wrap：换行，第一行在上方。"><a href="#（2）wrap：换行，第一行在上方。" class="headerlink" title="（2）wrap：换行，第一行在上方。"></a>（2）wrap：换行，第一行在上方。</h4><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt="Mou"></p>
<p>###（3）wrap-reverse：换行，第一行在下方。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt="Mou"></p>
<h3 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h3><hr>
<pre><code>.box {
      flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;
}
</code></pre><h3 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性"></a>3.4 justify-content属性</h3><h4 id="justify-content属性定义了项目在主轴上的对齐方式。"><a href="#justify-content属性定义了项目在主轴上的对齐方式。" class="headerlink" title="justify-content属性定义了项目在主轴上的对齐方式。"></a>justify-content属性定义了项目在主轴上的对齐方式。</h4><pre><code>.box {
      justify-content: flex-start | flex-end | center | space-between | space-around;
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="Mou"></p>
<h3 id="它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。"><a href="#它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。" class="headerlink" title="它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。"></a>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</h3><ul>
<li>flex-start（默认值）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center： 居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
<h3 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性"></a>3.5 align-items属性</h3><hr>
<h4 id="align-items属性定义项目在交叉轴上如何对齐。"><a href="#align-items属性定义项目在交叉轴上如何对齐。" class="headerlink" title="align-items属性定义项目在交叉轴上如何对齐。"></a>align-items属性定义项目在交叉轴上如何对齐。</h4><pre><code>.box {
      align-items: flex-start | flex-end | center | baseline | stretch;
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="Mou"></p>
<ul>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<h3 id="3-6-align-content属性"><a href="#3-6-align-content属性" class="headerlink" title="3.6 align-content属性"></a>3.6 align-content属性</h3><hr>
<h3 id="align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。"><a href="#align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。" class="headerlink" title="align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。"></a>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</h3><pre><code>.box {
      align-content: flex-start | flex-end | center | space-between | space-        around | stretch;
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="Mou"><br>该属性可能取6个值。</p>
<ul>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch（默认值）：轴线占满整个交叉轴。</li>
</ul>
<h3 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h3><hr>
<h3 id="order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。"><a href="#order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。" class="headerlink" title="order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。"></a>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</h3><pre><code>.item {
      order: &lt;integer&gt;;
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" alt="Mou"></p>
<h3 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h3><hr>
<h3 id="flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。"><a href="#flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。" class="headerlink" title="flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。"></a>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</h3><pre><code>.item {
      flex-grow: &lt;number&gt;; /* default 0 */
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" alt="Mou"></p>
<h5 id="如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。"><a href="#如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。" class="headerlink" title="如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。"></a>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</h5><h3 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h3><h4 id="flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。"><a href="#flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。" class="headerlink" title="flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。"></a>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</h4><pre><code>.item {
      flex-shrink: &lt;number&gt;; /* default 1 */
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" alt="Mou"></p>
<h5 id="如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。"><a href="#如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。" class="headerlink" title="如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。"></a>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</h5><h5 id="负值对该属性无效。"><a href="#负值对该属性无效。" class="headerlink" title="负值对该属性无效。"></a>负值对该属性无效。</h5><h3 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h3><hr>
<h4 id="flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main-size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。"><a href="#flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main-size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。" class="headerlink" title="flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。"></a>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</h4><pre><code>.item {
      flex-basis: &lt;length&gt; | auto; /* default auto */
}
</code></pre><h4 id="它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。"><a href="#它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。" class="headerlink" title="它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。"></a>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</h4><h3 id="4-5-flex属性"><a href="#4-5-flex属性" class="headerlink" title="4.5 flex属性"></a>4.5 flex属性</h3><hr>
<h3 id="flex属性是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto。后两个属性可选。"><a href="#flex属性是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto。后两个属性可选。" class="headerlink" title="flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。"></a>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</h3><pre><code>.item {
      flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]
}
</code></pre><h4 id="该属性有两个快捷值：auto-1-1-auto-和-none-0-0-auto-。"><a href="#该属性有两个快捷值：auto-1-1-auto-和-none-0-0-auto-。" class="headerlink" title="该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。"></a>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</h4><h4 id="建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。"><a href="#建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。" class="headerlink" title="建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。"></a>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</h4><p>###4.6 align-self属性</p>
<hr>
<h4 id="align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。"><a href="#align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。" class="headerlink" title="align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。"></a>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</h4><pre><code>.item {
      align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt="Mou"></p>
<h4 id="该属性可能取6个值，除了auto，其他都与align-items属性完全一致。"><a href="#该属性可能取6个值，除了auto，其他都与align-items属性完全一致。" class="headerlink" title="该属性可能取6个值，除了auto，其他都与align-items属性完全一致。"></a>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</h4><h4 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h4>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/12/布局教程：语法篇/" class="archive-article-date">
  	<time datetime="2016-11-12T07:07:56.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-12</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-布局教程：语法篇" data-title="" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"qianjenbo"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-Canvas六种特效滤镜" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="纯JavaScript实现HTML5-Canvas六种特效滤镜"><a href="#纯JavaScript实现HTML5-Canvas六种特效滤镜" class="headerlink" title="纯JavaScript实现HTML5 Canvas六种特效滤镜"></a>纯JavaScript实现HTML5 Canvas六种特效滤镜</h1><h4 id="纯JavaScript实现HTML5-Canvas六种特效滤镜-1"><a href="#纯JavaScript实现HTML5-Canvas六种特效滤镜-1" class="headerlink" title="纯JavaScript实现HTML5 Canvas六种特效滤镜"></a>纯JavaScript实现HTML5 Canvas六种特效滤镜</h4><p>小试牛刀，实现了六款简单常见Html5 Canvas特效滤镜，并且封装成一个纯</p>
<p>JavaScript可调用的API文件gloomyfishfilter.js。支持的特效滤镜分别为：</p>
<ol>
<li><p>反色</p>
</li>
<li><p>灰色调</p>
</li>
<li><p>模糊</p>
</li>
<li><p>浮雕</p>
</li>
<li><p>雕刻</p>
</li>
<li><p>镜像</p>
</li>
</ol>
<h4 id="滤镜原理解释："><a href="#滤镜原理解释：" class="headerlink" title="滤镜原理解释："></a>滤镜原理解释：</h4><ol>
<li><p>反色：获取一个像素点RGB值r, g, b则新的RGB值为(255-r, 255-g, 255-b)</p>
</li>
<li><p>灰色调：获取一个像素点RGB值r, g, b则新的RGB值为</p>
<pre><code>newr = (r * 0.272) + (g * 0.534) + (b * 0.131);

newg = (r * 0.349) + (g * 0.686) + (b * 0.168);

newb = (r * 0.393) + (g * 0.769) + (b * 0.189);
</code></pre></li>
<li><p>模糊：基于一个5*5的卷积核</p>
</li>
<li><p>浮雕与雕刻：</p>
<p>基于当前像素的前一个像素RGB值与它的后一个像素的RGB值之差再加上128</p>
</li>
<li><p>镜像：模拟了物体在镜子中与之对应的效果。</p>
</li>
</ol>
<h4 id="杂项准备"><a href="#杂项准备" class="headerlink" title="杂项准备"></a>杂项准备</h4><ol>
<li>如何获取Canvas 2d context对象</li>
</ol>
<p>var canvas = document.getElementById(“target”);</p>
<p>canvas.width = source.clientWidth;</p>
<p>canvas.height = source.clientHeight;</p>
<p>if(!canvas.getContext) {</p>
<pre><code>console.log(&quot;Canvas not supported. Please install a HTML5compatible browser.&quot;);

return;
</code></pre><p>}</p>
<p>// get 2D context of canvas and draw image</p>
<p>tempContext = canvas.getContext(“2d”);</p>
<p>2.如何绘制一个DOM img对象到Canvas对象中</p>
<p>var source = document.getElementById(“source”);</p>
<p>tempContext.drawImage(source, 0, 0, canvas.width,canvas.height);</p>
<p>3.如何从Canvas对象中获取像素数据</p>
<p>var canvas = document.getElementById(“target”);</p>
<p>varlen = canvas.width <em> canvas.height </em> 4;</p>
<p>var canvasData = tempContext.getImageData(0, 0, canvas.width, canvas.height);</p>
<p>var binaryData = canvasData.data;</p>
<p>4.如何对DOM对象实现鼠标Click事件绑定</p>
<p>function bindButtonEvent(element, type, handler) </p>
<p>{ </p>
<p>if(element.addEventListener){ </p>
<pre><code>   element.addEventListener(type, handler,false); 

}else { 

   element.attachEvent(&apos;on&apos;+type, handler);// for IE6,7,8

} 
</code></pre><p>}</p>
<p>5.如何调用实现的gfilter API完成滤镜功能</p>
<p><scriptsrc="gloomyfishfilter.js"> //导入API文件</scriptsrc="gloomyfishfilter.js"></p>
<p>gfilter.colorInvertProcess(binaryData, len); //调用 API</p>
<h2 id="效果演示："><a href="#效果演示：" class="headerlink" title="效果演示："></a>效果演示：</h2><p><img src="http://img.blog.csdn.net/20130628132241078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhMjAwMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="Mou"></p>
<h3 id="应用程序源代码：【css】部分"><a href="#应用程序源代码：【css】部分" class="headerlink" title="应用程序源代码：【css】部分"></a>应用程序源代码：【css】部分</h3><pre><code>#svgContainer {  
width:800px;  
height:600px;  
background-color:#EEEEEE;  
</code></pre><p>}  </p>
<pre><code>#sourceDiv { float: left; border: 2px solid blue}   
#targetDiv { float: right;border: 2px solid red}   
</code></pre><h3 id="filter1-html中HTML源代码：【html】部分"><a href="#filter1-html中HTML源代码：【html】部分" class="headerlink" title="filter1.html中HTML源代码：【html】部分"></a>filter1.html中HTML源代码：【html】部分</h3><pre><code>&lt;!DOCTYPE html&gt;  
&lt;html&gt;  
&lt;head&gt;  
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;chrome=IE8&quot;&gt;  
&lt;meta http-equiv=&quot;Content-type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;  
&lt;title&gt;Canvas Filter Demo&lt;/title&gt;  
&lt;link href=&quot;default.css&quot; rel=&quot;stylesheet&quot; /&gt;  
&lt;script src=&quot;gloomyfishfilter.js&quot;&gt;&lt;/scrip&gt;  
&lt;/head&gt;  
&lt;body&gt;  
&lt;h1&gt;HTML Canvas Image Process - By Gloomy Fish&lt;/h1&gt;  
&lt;div id=&quot;svgContainer&quot;&gt;  
    &lt;div id=&quot;sourceDiv&quot;&gt;  
        &lt;img id=&quot;source&quot; src=&quot;../test.png&quot; /&gt;  
    &lt;/div&gt;  
    &lt;div id=&quot;targetDiv&quot;&gt;  
        &lt;canvas id=&quot;target&quot;&gt;&lt;/canvas&gt;  
    &lt;/div&gt;  
&lt;/div&gt;  
&lt;div id=&quot;btn-group&quot;&gt;  
    &lt;button type=&quot;button&quot; id=&quot;invert-button&quot;&gt;反色&lt;/button&gt;  
    &lt;button type=&quot;button&quot; id=&quot;adjust-button&quot;&gt;灰色调&lt;/button&gt;  
    &lt;button type=&quot;button&quot; id=&quot;blur-button&quot;&gt;模糊&lt;/button&gt;  
    &lt;button type=&quot;button&quot; id=&quot;relief-button&quot;&gt;浮雕&lt;/button&gt;  
    &lt;button type=&quot;button&quot; id=&quot;diaoke-button&quot;&gt;雕刻&lt;/button&gt;  
    &lt;button type=&quot;button&quot; id=&quot;mirror-button&quot;&gt;镜像&lt;/button&gt;  
&lt;/div&gt;  
&lt;/body&gt;  
&lt;/html&gt; 
</code></pre><h3 id="filter1-html中JavaScript源代码：【javascript】"><a href="#filter1-html中JavaScript源代码：【javascript】" class="headerlink" title="filter1.html中JavaScript源代码：【javascript】"></a>filter1.html中JavaScript源代码：【javascript】</h3><pre><code>var tempContext = null; // global variable 2d context  
</code></pre><p>window.onload = function() {<br>    var source = document.getElementById(“source”);<br>    var canvas = document.getElementById(“target”);<br>    canvas.width = source.clientWidth;<br>    canvas.height = source.clientHeight;  </p>
<pre><code>if (!canvas.getContext) {  
    console.log(&quot;Canvas not supported. Please install a HTML5 compatible browser.&quot;);  
    return;  
}  

// get 2D context of canvas and draw image  
tempContext = canvas.getContext(&quot;2d&quot;);  
tempContext.drawImage(source, 0, 0, canvas.width, canvas.height);  

   // initialization actions  
   var inButton = document.getElementById(&quot;invert-button&quot;);  
   var adButton = document.getElementById(&quot;adjust-button&quot;);  
   var blurButton = document.getElementById(&quot;blur-button&quot;);  
   var reButton = document.getElementById(&quot;relief-button&quot;);  
   var dkButton = document.getElementById(&quot;diaoke-button&quot;);  
   var mirrorButton = document.getElementById(&quot;mirror-button&quot;);  

   // bind mouse click event  
   bindButtonEvent(inButton, &quot;click&quot;, invertColor);  
   bindButtonEvent(adButton, &quot;click&quot;, adjustColor);  
   bindButtonEvent(blurButton, &quot;click&quot;, blurImage);  
   bindButtonEvent(reButton, &quot;click&quot;, fudiaoImage);  
   bindButtonEvent(dkButton, &quot;click&quot;, kediaoImage);  
   bindButtonEvent(mirrorButton, &quot;click&quot;, mirrorImage);  
}  

function bindButtonEvent(element, type, handler)    
{    
if(element.addEventListener) {    
   element.addEventListener(type, handler, false);    
} else {    
   element.attachEvent(&apos;on&apos;+type, handler); // for IE6,7,8  
}    
}    

function invertColor() {  
var canvas = document.getElementById(&quot;target&quot;);  
var len = canvas.width * canvas.height * 4;  
var canvasData = tempContext.getImageData(0, 0, canvas.width, canvas.height);  
var binaryData = canvasData.data;  

   // Processing all the pixels  
   gfilter.colorInvertProcess(binaryData, len);  

   // Copying back canvas data to canvas  
   tempContext.putImageData(canvasData, 0, 0);  
}  

function adjustColor() {  
var canvas = document.getElementById(&quot;target&quot;);  
var len = canvas.width * canvas.height * 4;  
var canvasData = tempContext.getImageData(0, 0, canvas.width, canvas.height);  
   var binaryData = canvasData.data;  

   // Processing all the pixels  
   gfilter.colorAdjustProcess(binaryData, len);  

   // Copying back canvas data to canvas  
   tempContext.putImageData(canvasData, 0, 0);  
}  

function blurImage()   
{  
var canvas = document.getElementById(&quot;target&quot;);  
var len = canvas.width * canvas.height * 4;  
var canvasData = tempContext.getImageData(0, 0, canvas.width, canvas.height);  

   // Processing all the pixels  
   gfilter.blurProcess(tempContext, canvasData);  

   // Copying back canvas data to canvas  
   tempContext.putImageData(canvasData, 0, 0);  
}  

function fudiaoImage()   
{  
var canvas = document.getElementById(&quot;target&quot;);  
var len = canvas.width * canvas.height * 4;  
var canvasData = tempContext.getImageData(0, 0, canvas.width, canvas.height);  

   // Processing all the pixels  
   gfilter.reliefProcess(tempContext, canvasData);  

   // Copying back canvas data to canvas  
   tempContext.putImageData(canvasData, 0, 0);  
}  

function kediaoImage()   
{  
    var canvas = document.getElementById(&quot;target&quot;);  
    var len = canvas.width * canvas.height * 4;  
    var canvasData = tempContext.getImageData(0, 0, canvas.width, canvas.height);  

   // Processing all the pixels  
   gfilter.diaokeProcess(tempContext, canvasData);  

   // Copying back canvas data to canvas  
   tempContext.putImageData(canvasData, 0, 0);  
}  

function mirrorImage()   
{  
var canvas = document.getElementById(&quot;target&quot;);  
var len = canvas.width * canvas.height * 4;  
var canvasData = tempContext.getImageData(0, 0, canvas.width, canvas.height);  

   // Processing all the pixels  
   gfilter.mirrorProcess(tempContext, canvasData);  

   // Copying back canvas data to canvas  
   tempContext.putImageData(canvasData, 0, 0);  
} 
</code></pre><h3 id="滤镜源代码-gloomyfishfilter-js-："><a href="#滤镜源代码-gloomyfishfilter-js-：" class="headerlink" title="滤镜源代码(gloomyfishfilter.js)："></a>滤镜源代码(gloomyfishfilter.js)：</h3><pre><code>    var gfilter = {  
    type: &quot;canvas&quot;,  
    name: &quot;filters&quot;,  
    author: &quot;zhigang&quot;,  
    getInfo: function () {  
    return this.author + &apos; &apos; + this.type + &apos; &apos; + this.name;  
    },  

/** 
 * invert color value of pixel, new pixel = RGB(255-r, 255-g, 255 - b) 
 *  
 * @param binaryData - canvas&apos;s imagedata.data 
 * @param l - length of data (width * height of image data) 
 */  
colorInvertProcess: function(binaryData, l) {  
    for (var i = 0; i &lt; l; i += 4) {  
        var r = binaryData[i];  
        var g = binaryData[i + 1];  
        var b = binaryData[i + 2];  

        binaryData[i] = 255-r;  
        binaryData[i + 1] = 255-g;  
        binaryData[i + 2] = 255-b;  
    }  
},  

/** 
 * adjust color values and make it more darker and gray... 
 *  
 * @param binaryData 
 * @param l 
 */  
colorAdjustProcess: function(binaryData, l) {  
    for (var i = 0; i &lt; l; i += 4) {  
        var r = binaryData[i];  
        var g = binaryData[i + 1];  
        var b = binaryData[i + 2];  

        binaryData[i] = (r * 0.272) + (g * 0.534) + (b * 0.131);  
        binaryData[i + 1] = (r * 0.349) + (g * 0.686) + (b * 0.168);  
        binaryData[i + 2] = (r * 0.393) + (g * 0.769) + (b * 0.189);  
    }  
},  

/** 
 * deep clone image data of canvas 
 *  
 * @param context 
 * @param src 
 * @returns 
 */  
copyImageData: function(context, src)  
{  
    var dst = context.createImageData(src.width, src.height);  
    dst.data.set(src.data);  
    return dst;  
},  

/** 
 * convolution - keneral size 5*5 - blur effect filter(模糊效果) 
 *  
 * @param context 
 * @param canvasData 
 */  
blurProcess: function(context, canvasData) {  
    console.log(&quot;Canvas Filter - blur process&quot;);  
    var tempCanvasData = this.copyImageData(context, canvasData);  
    var sumred = 0.0, sumgreen = 0.0, sumblue = 0.0;  
    for ( var x = 0; x &lt; tempCanvasData.width; x++) {      
        for ( var y = 0; y &lt; tempCanvasData.height; y++) {      

            // Index of the pixel in the array      
            var idx = (x + y * tempCanvasData.width) * 4;         
            for(var subCol=-2; subCol&lt;=2; subCol++) {  
                var colOff = subCol + x;  
                if(colOff &lt;0 || colOff &gt;= tempCanvasData.width) {  
                    colOff = 0;  
                }  
                for(var subRow=-2; subRow&lt;=2; subRow++) {  
                    var rowOff = subRow + y;  
                    if(rowOff &lt; 0 || rowOff &gt;= tempCanvasData.height) {  
                        rowOff = 0;  
                    }  
                    var idx2 = (colOff + rowOff * tempCanvasData.width) * 4;      
                    var r = tempCanvasData.data[idx2 + 0];      
                    var g = tempCanvasData.data[idx2 + 1];      
                    var b = tempCanvasData.data[idx2 + 2];  
                    sumred += r;  
                    sumgreen += g;  
                    sumblue += b;  
                }  
            }  

            // calculate new RGB value  
            var nr = (sumred / 25.0);  
            var ng = (sumgreen / 25.0);  
            var nb = (sumblue / 25.0);  

            // clear previous for next pixel point  
            sumred = 0.0;  
            sumgreen = 0.0;  
            sumblue = 0.0;  

            // assign new pixel value      
            canvasData.data[idx + 0] = nr; // Red channel      
            canvasData.data[idx + 1] = ng; // Green channel      
            canvasData.data[idx + 2] = nb; // Blue channel      
            canvasData.data[idx + 3] = 255; // Alpha channel      
        }  
    }  
},  

/** 
 * after pixel value - before pixel value + 128 
 * 浮雕效果 
 */  
reliefProcess: function(context, canvasData) {  
    console.log(&quot;Canvas Filter - relief process&quot;);  
    var tempCanvasData = this.copyImageData(context, canvasData);  
    for ( var x = 1; x &lt; tempCanvasData.width-1; x++)   
    {      
        for ( var y = 1; y &lt; tempCanvasData.height-1; y++)  
        {      

            // Index of the pixel in the array      
            var idx = (x + y * tempCanvasData.width) * 4;         
            var bidx = ((x-1) + y * tempCanvasData.width) * 4;  
            var aidx = ((x+1) + y * tempCanvasData.width) * 4;  

            // calculate new RGB value  
            var nr = tempCanvasData.data[aidx + 0] - tempCanvasData.data[bidx + 0] + 128;  
            var ng = tempCanvasData.data[aidx + 1] - tempCanvasData.data[bidx + 1] + 128;  
            var nb = tempCanvasData.data[aidx + 2] - tempCanvasData.data[bidx + 2] + 128;  
            nr = (nr &lt; 0) ? 0 : ((nr &gt;255) ? 255 : nr);  
            ng = (ng &lt; 0) ? 0 : ((ng &gt;255) ? 255 : ng);  
            nb = (nb &lt; 0) ? 0 : ((nb &gt;255) ? 255 : nb);  

            // assign new pixel value      
            canvasData.data[idx + 0] = nr; // Red channel      
            canvasData.data[idx + 1] = ng; // Green channel      
            canvasData.data[idx + 2] = nb; // Blue channel      
            canvasData.data[idx + 3] = 255; // Alpha channel      
        }  
    }  
},  

/** 
 *  before pixel value - after pixel value + 128 
 *  雕刻效果 
 *  
 * @param canvasData 
 */  
diaokeProcess: function(context, canvasData) {  
    console.log(&quot;Canvas Filter - process&quot;);  
    var tempCanvasData = this.copyImageData(context, canvasData);  
    for ( var x = 1; x &lt; tempCanvasData.width-1; x++)   
    {      
        for ( var y = 1; y &lt; tempCanvasData.height-1; y++)  
        {      

            // Index of the pixel in the array      
            var idx = (x + y * tempCanvasData.width) * 4;         
            var bidx = ((x-1) + y * tempCanvasData.width) * 4;  
            var aidx = ((x+1) + y * tempCanvasData.width) * 4;  

            // calculate new RGB value  
            var nr = tempCanvasData.data[bidx + 0] - tempCanvasData.data[aidx + 0] + 128;  
            var ng = tempCanvasData.data[bidx + 1] - tempCanvasData.data[aidx + 1] + 128;  
            var nb = tempCanvasData.data[bidx + 2] - tempCanvasData.data[aidx + 2] + 128;  
            nr = (nr &lt; 0) ? 0 : ((nr &gt;255) ? 255 : nr);  
            ng = (ng &lt; 0) ? 0 : ((ng &gt;255) ? 255 : ng);  
            nb = (nb &lt; 0) ? 0 : ((nb &gt;255) ? 255 : nb);  

            // assign new pixel value      
            canvasData.data[idx + 0] = nr; // Red channel      
            canvasData.data[idx + 1] = ng; // Green channel      
            canvasData.data[idx + 2] = nb; // Blue channel      
            canvasData.data[idx + 3] = 255; // Alpha channel      
        }  
    }  
},  

/** 
 * mirror reflect 
 *  
 * @param context 
 * @param canvasData 
 */  
mirrorProcess : function(context, canvasData) {  
    console.log(&quot;Canvas Filter - process&quot;);  
    var tempCanvasData = this.copyImageData(context, canvasData);  
    for ( var x = 0; x &lt; tempCanvasData.width; x++) // column  
    {      
        for ( var y = 0; y &lt; tempCanvasData.height; y++) // row  
        {      

            // Index of the pixel in the array      
            var idx = (x + y * tempCanvasData.width) * 4;         
            var midx = (((tempCanvasData.width -1) - x) + y * tempCanvasData.width) * 4;  

            // assign new pixel value      
            canvasData.data[midx + 0] = tempCanvasData.data[idx + 0]; // Red channel      
            canvasData.data[midx + 1] = tempCanvasData.data[idx + 1]; ; // Green channel      
            canvasData.data[midx + 2] = tempCanvasData.data[idx + 2]; ; // Blue channel      
            canvasData.data[midx + 3] = 255; // Alpha channel      
        }  
    }  
},  
};  
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/12/Canvas六种特效滤镜/" class="archive-article-date">
  	<time datetime="2016-11-12T07:03:12.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-12</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-Canvas六种特效滤镜" data-title="" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"qianjenbo"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 qianjenbo
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/qianjianbo/">啵啵啵博客园</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/Jasonellen/">奋斗蚁博客园</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://jasonellen.github.io/">奋斗蚁github</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://yang867381349.github.io">杨军权githob</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://duhan96.github.io/">杜🐶</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jianshu.com/users/926dbfef1d19/latest_articles">杜涵简书</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>