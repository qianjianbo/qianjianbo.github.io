<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>canvas画图 | 啵啵啵</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="导航
前言
基本知识
绘制矩形
清除矩形区域
圆弧
路径
绘制线段
绘制贝塞尔曲线
线性渐变
径向渐变（发散）
图形变形（平移、旋转、缩放）
矩阵变换（图形变形的机制）
图形组合
给图形绘制阴影
绘制图像（图片平铺、裁剪、像素处理[不只图像、包括其他绘制图形]）
绘制文字
保存和恢复状态（context）
保存文件
结合setInterval制作动画
结语、demo下载

前言&amp;lt;canvas">
<meta property="og:type" content="article">
<meta property="og:title" content="canvas画图">
<meta property="og:url" content="http://yoursite.com/2016/11/16/canvas画图/index.html">
<meta property="og:site_name" content="啵啵啵">
<meta property="og:description" content="导航
前言
基本知识
绘制矩形
清除矩形区域
圆弧
路径
绘制线段
绘制贝塞尔曲线
线性渐变
径向渐变（发散）
图形变形（平移、旋转、缩放）
矩阵变换（图形变形的机制）
图形组合
给图形绘制阴影
绘制图像（图片平铺、裁剪、像素处理[不只图像、包括其他绘制图形]）
绘制文字
保存和恢复状态（context）
保存文件
结合setInterval制作动画
结语、demo下载

前言&amp;lt;canvas">
<meta property="og:image" content="http://www.uml.org.cn/html/images/2012082241.jpg">
<meta property="og:image" content="http://www.uml.org.cn/html/images/2012082242.jpg">
<meta property="og:image" content="http://www.uml.org.cn/html/images/2012082243.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/2012082245.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/2012082246.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/2012082247.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/2012082248.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/2012082249.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822410.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822411.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822412.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822413.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822414.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822415.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822416.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822417.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822418.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822419.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822420.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822421.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822422.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822423.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822424.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822424.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822426.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822427.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822428.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822429.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822430.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822431.png">
<meta property="og:image" content="http://www.uml.org.cn/html/images/20120822432.png">
<meta property="og:updated_time" content="2016-11-16T12:28:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="canvas画图">
<meta name="twitter:description" content="导航
前言
基本知识
绘制矩形
清除矩形区域
圆弧
路径
绘制线段
绘制贝塞尔曲线
线性渐变
径向渐变（发散）
图形变形（平移、旋转、缩放）
矩阵变换（图形变形的机制）
图形组合
给图形绘制阴影
绘制图像（图片平铺、裁剪、像素处理[不只图像、包括其他绘制图形]）
绘制文字
保存和恢复状态（context）
保存文件
结合setInterval制作动画
结语、demo下载

前言&amp;lt;canvas">
<meta name="twitter:image" content="http://www.uml.org.cn/html/images/2012082241.jpg">
  
  
    <link rel="icon" href="https://avatars0.githubusercontent.com/u/20942842?v=3&u=d1a97114e82a12c99a99e1cf4d13fffad7756cd7&s=140">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="https://avatars0.githubusercontent.com/u/20942842?v=3&amp;u=d1a97114e82a12c99a99e1cf4d13fffad7756cd7&amp;s=140" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">qianjenbo</a></h1>
		</hgroup>

		
		<p class="header-subtitle">有时候缺的就是破釜沉舟的勇气，把自己逼一逼，才知道自己有多大潜力！</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="http://www.suibi8.com/">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/qianjianbo" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://t.qq.com/qianjianbo777?preview" title="weibo">weibo</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">qianjenbo</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://avatars0.githubusercontent.com/u/20942842?v=3&amp;u=d1a97114e82a12c99a99e1cf4d13fffad7756cd7&amp;s=140" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">qianjenbo</h1>
			</hgroup>
			
			<p class="header-subtitle">有时候缺的就是破釜沉舟的勇气，把自己逼一逼，才知道自己有多大潜力！</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="http://www.suibi8.com/">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/qianjianbo" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://t.qq.com/qianjianbo777?preview" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="玩转html5-canvas画图" class="article article-type-玩转html5" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      canvas画图
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><ul>
<li>前言</li>
<li>基本知识</li>
<li>绘制矩形</li>
<li>清除矩形区域</li>
<li>圆弧</li>
<li>路径</li>
<li>绘制线段</li>
<li>绘制贝塞尔曲线</li>
<li>线性渐变</li>
<li>径向渐变（发散）</li>
<li>图形变形（平移、旋转、缩放）</li>
<li>矩阵变换（图形变形的机制）</li>
<li>图形组合</li>
<li>给图形绘制阴影</li>
<li>绘制图像（图片平铺、裁剪、像素处理[不只图像、包括其他绘制图形]）</li>
<li>绘制文字</li>
<li>保存和恢复状态（context）</li>
<li>保存文件</li>
<li>结合setInterval制作动画</li>
<li>结语、demo下载</li>
</ul>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><pre><code>&lt;canvas&gt;&lt;/canvas&gt;是html5出现的新标签，像所有的dom对象一样它有自己本身的属性、方法和事件，其中就有绘图的方法，js能够调用它来进行绘图 ，最近在研读《html5与css3权威指南》下面对其中最好玩的canvas的学习做下读书笔记与实验。
</code></pre><p>温馨提示：以下所有实验请使用最新版的opera</p>
<h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>context:一直觉得这个翻译成“上下文”真够蛋疼的，context是一个封装了很多绘图功能的对象，获取这个对象的方法是</p>
<p>var context =canvas.getContext(“2d”);</p>
<p>也许这个2d勾起了大家的无限遐想，但是很遗憾的告诉你html5还只是个少女，不提供3d服务。</p>
<p>canvas元素绘制图像的时候有两种方法，分别是</p>
<p>context.fill()//填充</p>
<p>context.stroke()//绘制边框</p>
<p>style:在进行图形绘制前，要设置好绘图的样式</p>
<p>context.fillStyle//填充的样式</p>
<p>context.strokeStyle//边框样式</p>
<p>context.lineWidth//图形边框宽度</p>
<p>颜色的表示方式:</p>
<p>直接用颜色名称:”red” “green” “blue”</p>
<p>十六进制颜色值: “#EEEEFF”</p>
<p>rgb(1-255,1-255,1-255)</p>
<p>rgba(1-255,1-255,1-255,透明度)</p>
<p>和GDI是如此的相像，所以用过GDI的朋友应该很快就能上手</p>
<h5 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h5><p>context.fillRect(x,y,width,height) strokeRect(x,y,width,height)</p>
<p>x:矩形起点横坐标（坐标原点为canvas的左上角，当然确切的来说是原始原点，后面写到变形的时候你就懂了，现在暂时不用关系）</p>
<p>y:矩形起点纵坐标</p>
<p>width:矩形长度</p>
<p>height:矩形高度</p>
<pre><code>View Code 
 function draw21(id) {
         var canvas = document.getElementById(id)
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         //实践表明在不设施fillStyle下的默认fillStyle=black
         context.fillRect(0, 0, 100, 100);
         //实践表明在不设施strokeStyle下的默认strokeStyle=black
         context.strokeRect(120, 0, 100, 100);

         //设置纯色
         context.fillStyle = &quot;red&quot;;
         context.strokeStyle = &quot;blue&quot;;
         context.fillRect(0, 120, 100, 100);
         context.strokeRect(120, 120, 100, 100);

         //设置透明度实践证明透明度值&gt;0,&lt;1值越低，越透明，值&gt;=1时为纯色，值&lt;=0时为完全透明
         context.fillStyle = &quot;rgba(255,0,0,0.2)&quot;;
         context.strokeStyle = &quot;rgba(255,0,0,0.2)&quot;;
         context.fillRect(240,0 , 100, 100);
         context.strokeRect(240, 120, 100, 100);
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/2012082241.jpg" alt="Mou"></p>
<h4 id="清除矩形区域"><a href="#清除矩形区域" class="headerlink" title="清除矩形区域"></a>清除矩形区域</h4><p>context.clearRect(x,y,width,height)</p>
<p>x:清除矩形起点横坐标</p>
<p>y:清除矩形起点纵坐标</p>
<p>width:清除矩形长度</p>
<p>height:清除矩形高度</p>
<pre><code>View Code 
   function draw22(id) {
         var canvas = document.getElementById(id)
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         //实践表明在不设施fillStyle下的默认fillStyle=black
         context.fillRect(0, 0, 100, 100);
         //实践表明在不设施strokeStyle下的默认strokeStyle=black
         context.strokeRect(120, 0, 100, 100);

         //设置纯色
         context.fillStyle = &quot;red&quot;;
         context.strokeStyle = &quot;blue&quot;;
         context.fillRect(0, 120, 100, 100);
         context.strokeRect(120, 120, 100, 100);

         //设置透明度实践证明透明度值&gt;0,&lt;1值越低，越透明，值&gt;=1时为纯色，值&lt;=0时为完全透明
         context.fillStyle = &quot;rgba(255,0,0,0.2)&quot;;
         context.strokeStyle = &quot;rgba(255,0,0,0.2)&quot;;
         context.fillRect(240, 0, 100, 100);
         context.strokeRect(240, 120, 100, 100);
         context.clearRect(50, 50, 240, 120);
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/2012082242.jpg" alt="Mou"></p>
<h3 id="圆弧"><a href="#圆弧" class="headerlink" title="圆弧"></a>圆弧</h3><p>context.arc(x, y, radius, starAngle,endAngle, anticlockwise)</p>
<p>x:圆心的x坐标</p>
<p>y:圆心的y坐标</p>
<p>straAngle:开始角度</p>
<p>endAngle:结束角度</p>
<p>anticlockwise:是否逆时针（true）为逆时针，(false)为顺时针</p>
<p>ps：经过试验证明书本上ture是顺时针，false是逆时针是错误的，而且无论是逆时针还是顺时针，角度都沿着顺时针扩大，如下图：</p>
<p><img src="http://www.uml.org.cn/html/images/2012082243.png" alt="Mou"></p>
<pre><code>View Code 
     function draw0(id) {
         var canvas = document.getElementById(id);
         if (canvas == null) {
             return false;
         }
         var context = canvas.getContext(&apos;2d&apos;);
         context.beginPath();
         context.arc(200, 150, 100, 0, Math.PI * 2, true);
         //不关闭路径路径会一直保留下去，当然也可以利用这个特点做出意想不到的效果
         context.closePath();
         context.fillStyle = &apos;rgba(0,255,0,0.25)&apos;;
         context.fill();
     } 
</code></pre><p>一不小心画了小日本的国旗…赶紧调下颜色和大小，绿色倒是挺合适的~</p>
<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>context.beginPath() context.closePath()</p>
<p>细心的朋友会发现上面的画圆并不单单是直接用arc还用到了context的 beginPath 和closePath方法，参考书不愧是参考书，例子给得太简单了，实话说一开始我凌乱了，耐心下来做了几个实验才舒缓蛋疼的心情</p>
<p>实验代码如下，通过分别注释closePath 和beginPath看fill stoke 和fill stroke结合下画出来的两个1/4弧线达到实验效果</p>
<pre><code>View Code 
   function draw23(id) {
         var canvas = document.getElementById(id);
         if (canvas == null) {
             return false;
         }
         var context = canvas.getContext(&apos;2d&apos;);
         var n = 0;

         //左侧1/4圆弧
         context.beginPath();
         context.arc(100, 150, 50, 0, Math.PI/2 , false);
         context.fillStyle = &apos;rgba(255,0,0,0.25)&apos;;
         context.fill();
         context.strokeStyle = &apos;rgba(255,0,0,0.25)&apos;
         context.closePath();
         context.stroke();

         //右侧1/4圆弧
         context.beginPath();
         context.arc(300, 150, 50, 0, Math.PI/2 , false);
         context.fillStyle = &apos;rgba(255,0,0,0.25)&apos;;
         context.fill();
         context.strokeStyle = &apos;rgba(255,0,0,0.25)&apos;;
         context.closePath();
         context.stroke();
     } 
</code></pre><p>实验结果如下：<br> <img src="http://www.uml.org.cn/html/images/2012082245.png" alt="Mou"><br> 得出的结论有：*号为重点</p>
<p>1、系统默认在绘制第一个路径的开始点为beginPath</p>
<p>*2、如果画完前面的路径没有重新指定beginPath，那么画第其他路径的时候会将前面最近指定的beginPath后的全部路径重新绘制</p>
<p>3、每次调用context.fill（）的时候会自动把当次绘制的路径的开始点和结束点相连，接着填充封闭的部分</p>
<p>ps：书本的结论是 如果没有closePath那么前面的路劲会保留，实验证明正确的结论是 如果没有重新beginPath那么前面的路劲会保留</p>
<p>ps1：如果你真心凌乱了，那么记住每次画路径都在前后加context.beginPath() 和context.closePath()就行</p>
<p>绘制线段 context.moveTo(x,y) context.lineTo(x,y)</p>
<p>x:x坐标</p>
<p>y:y坐标</p>
<p>每次画线都从moveTo的点到lineTo的点，</p>
<p>如果没有moveTo那么第一次lineTo的效果和moveTo一样，</p>
<p>每次lineTo后如果没有moveTo，那么下次lineTo的开始点为前一次lineTo的结束点</p>
<pre><code>View Code 
 function draw8(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         //context.beginPath();
         context.strokeStyle = &quot;rgb(250,0,0)&quot;;
         context.fillStyle = &quot;rgb(250,0,0)&quot;
         //实验证明第一次lineTo的时候和moveTo功能一样
         context.lineTo(100, 100);
         //之后的lineTo会以上次lineTo的节点为开始
         context.lineTo(200, 200);
         context.lineTo(200, 100);
         context.moveTo(200, 50);
         context.lineTo(100,50);
         context.stroke();
     } 
</code></pre><p> <img src="http://www.uml.org.cn/html/images/2012082246.png" alt="Mou"></p>
<p> 下面给出书本的例子，一朵绿色的菊花，涉及数学，不多解析，有兴趣的自己研究</p>
<pre><code>View Code 
   function draw1(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         context.fillStyle = &quot;#EEEEFF&quot;;
         context.fillRect(0, 0, 400, 300);
         var n = 0;
         var dx = 150;
         var dy = 150;
         var s = 100;
         context.beginPath();
         context.fillStyle = &apos;rgb(100,255,100)&apos;;
         context.strokeStyle = &apos;rgb(0,0,100)&apos;;
         var x = Math.sin(0);
         var y = Math.cos(0);
         var dig = Math.PI / 15 * 11;
         for (var i = 0; i &lt; 30; i++) {
             var x = Math.sin(i * dig);
             var y = Math.cos(i * dig);
             context.lineTo(dx + x * s, dy + y * s);
         }
         context.closePath();
         context.fill();
         context.stroke();

     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/2012082247.png" alt="Mou"></p>
<h3 id="绘制贝塞尔曲线"><a href="#绘制贝塞尔曲线" class="headerlink" title="绘制贝塞尔曲线"></a>绘制贝塞尔曲线</h3><p>（贝济埃、bezier） context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y)</p>
<p>绘制二次样条曲线 context.quadraticCurveTo(qcpx,qcpy,qx,qy)</p>
<p>cp1x:第一个控制点x坐标</p>
<p>cp1y:第一个控制点y坐标</p>
<p>cp2x:第二个控制点x坐标</p>
<p>cp2y:第二个控制点y坐标</p>
<p>x:终点x坐标</p>
<p>y:终点y坐标</p>
<p>qcpx:二次样条曲线控制点x坐标</p>
<p>qcpy:二次样条曲线控制点y坐标</p>
<p>qx:二次样条曲线终点x坐标</p>
<p>qy:二次样条曲线终点y坐标</p>
<pre><code>View Code 
     function draw24(id) {
         var canvas = document.getElementById(id);
         if (canvas == null) {
             return false;
         }
         var context = canvas.getContext(&quot;2d&quot;);

         context.moveTo(50, 50);
         context.bezierCurveTo(50, 50,150, 50, 150, 150);
         context.stroke();
         context.quadraticCurveTo(150, 250, 250, 250);
         context.stroke();
     } 
</code></pre><p>  <img src="http://www.uml.org.cn/html/images/2012082248.png" alt="Mou"><br>  下面给出书本的例子，一朵扭曲的绿色菊花…编书这哥们对菊花情有独钟啊- -</p>
<pre><code>View Code 
     function draw2(id) {
         var canvas = document.getElementById(id);
         if (canvas == null) {
             return false;
         }
         var context = canvas.getContext(&quot;2d&quot;);
         context.fillStyle = &quot;#EEEFF&quot;;
         context.fillRect(0, 0, 400, 300);
         var n = 0;
         var dx = 150;
         var dy = 150;
         var s = 100;
         context.beginPath();
         context.globalCompositeOperation = &apos;and&apos;;
         context.fillStyle = &apos;rgb(100,255,100)&apos;;
         var x = Math.sin(0);
         var y = Math.cos(0);
         var dig = Math.PI / 15 * 11;
         context.moveTo(dx, dy);
         for (var i = 0; i &lt; 30; i++) {
             var x = Math.sin(i * dig);
             var y = Math.cos(i * dig);
             context.bezierCurveTo(dx + x * s, dy + y * s - 100, dx + x * s + 100, dy + y * s, dx + x * s, 
              dy + y * s);
         }
         context.closePath();
         context.fill();
         context.stroke();
     }   
</code></pre><p>  <img src="http://www.uml.org.cn/html/images/2012082249.png" alt="Mou">    </p>
<h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><p>var lg= context.createLinearGradient(xStart,yStart,xEnd,yEnd)</p>
<p>线性渐变颜色lg.addColorStop(offset,color)</p>
<p>xstart:渐变开始点x坐标</p>
<p>ystart:渐变开始点y坐标</p>
<p>xEnd:渐变结束点x坐标</p>
<p>yEnd:渐变结束点y坐标</p>
<p>offset:设定的颜色离渐变结束点的偏移量(0~1)</p>
<p>color:绘制时要使用的颜色</p>
<p>给出书本偏移量的解析图，从图可以看出线性渐变可以是两种以上颜色的渐变</p>
<p><img src="http://www.uml.org.cn/html/images/20120822410.png" alt="Mou">  </p>
<pre><code>View Code 
     function draw25(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&apos;2d&apos;);
         var g1 = context.createLinearGradient(0, 0, 0, 300);

         g1.addColorStop(0, &apos;rgb(255,0,0)&apos;); //红 
         g1.addColorStop(0.5, &apos;rgb(0,255,0)&apos;);//绿
         g1.addColorStop(1, &apos;rgb(0,0,255)&apos;); //蓝

         //可以把lg对象理解成GDI中线性brush
         context.fillStyle = g1;
         //再用这个brush来画正方形
          context.fillRect(0, 0, 400, 300); 
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822411.png" alt="Mou">  </p>
<h3 id="径向渐变（发散）"><a href="#径向渐变（发散）" class="headerlink" title="径向渐变（发散）"></a>径向渐变（发散）</h3><p>var rg=context.createRadialGradient(xStart,yStart,radiusStart,xEnd,yEnd,radiusEnd)</p>
<p>径向渐变（发散）颜色rg.addColorStop(offset,color)</p>
<p>xStart:发散开始圆心x坐标</p>
<p>yStart:发散开始圆心y坐标</p>
<p>radiusStart:发散开始圆的半径</p>
<p>xEnd:发散结束圆心的x坐标</p>
<p>yEnd:发散结束圆心的y坐标</p>
<p>radiusEnd:发散结束圆的半径</p>
<p>offset:设定的颜色离渐变结束点的偏移量(0~1)</p>
<p>color:绘制时要使用的颜色</p>
<p>书本并没有给出发散偏移量的图，特地画了幅：</p>
<p><img src="http://www.uml.org.cn/html/images/20120822412.png" alt="Mou"><br>下面给出两个实验</p>
<pre><code>View Code 
     function draw26(id) {
         //同一个圆心画球型
         /*var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&apos;2d&apos;);
         var g1 = context.createRadialGradient(200, 150, 0, 200, 150, 100);
         g1.addColorStop(0.1, &apos;rgb(255,0,0)&apos;);  
         g1.addColorStop(1, &apos;rgb(50,0,0)&apos;);
         context.fillStyle = g1;
         context.beginPath();
         context.arc(200, 150, 100, 0, Math.PI * 2, true);
         context.closePath();
         context.fill();*/

         //不同圆心看径向渐变模型
         var canvas = document.getElementById(id);
         if (canvas == null)
         return false;
         var context = canvas.getContext(&apos;2d&apos;);
         var g1 = context.createRadialGradient(100, 150, 10, 300, 150, 50);
         g1.addColorStop(0.1, &apos;rgb(255,0,0)&apos;);
         g1.addColorStop(0.5, &apos;rgb(0,255,0)&apos;);
         g1.addColorStop(1, &apos;rgb(0,0,255)&apos;);
         context.fillStyle = g1;
         context.fillRect(0, 0, 400, 300);

     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822413.png" alt="Mou">   </p>
<p><img src="http://www.uml.org.cn/html/images/20120822414.png" alt="Mou">   </p>
<h3 id="图形变形"><a href="#图形变形" class="headerlink" title="图形变形"></a>图形变形</h3><p>1、平移context.translate(x,y)</p>
<p>x:坐标原点向x轴方向平移x</p>
<p>y:坐标原点向y轴方向平移y</p>
<p>2、缩放context.scale(x,y)</p>
<p>x:x坐标轴按x比例缩放</p>
<p>y:y坐标轴按y比例缩放</p>
<p>3、旋转context.rotate(angle)</p>
<p>angle:坐标轴旋转x角度（角度变化模型和画圆的模型一样）</p>
<pre><code>View Code 
     function draw5(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;


         var context = canvas.getContext(&quot;2d&quot;);
         context.save(); //保存了当前context的状态
         context.fillStyle = &quot;#EEEEFF&quot;;
         context.fillRect(0, 0, 400, 300);

         context.fillStyle = &quot;rgba(255,0,0,0.1)&quot;;
         //平移 缩放 旋转  1 2 3        
         context.translate(100, 100);
         context.scale(0.5, 0.5);
         context.rotate(Math.PI / 4);
         context.fillRect(0, 0, 100, 100);


         context.restore(); //恢复到刚刚保存的状态,保存恢复只能使用一次
         context.save(); //保存了当前context的状态
         context.fillStyle = &quot;rgba(255,0,0,0.2)&quot;;
         //平移 旋转 缩放 1 3 2
         context.translate(100, 100);
         context.rotate(Math.PI / 4);
         context.scale(0.5, 0.5);
         context.fillRect(0, 0, 100, 100);

         context.restore(); //恢复到刚刚保存的状态
         context.save(); //保存了当前context的状态
         context.fillStyle = &quot;rgba(255,0,0,0.3)&quot;;
         //缩放 平移 旋转 2 1 3 
         context.scale(0.5, 0.5);
         context.translate(100, 100);
         context.rotate(Math.PI / 4);
         context.fillRect(0, 0, 100, 100);

         context.restore(); //恢复到刚刚保存的状态
         context.save(); //保存了当前context的状态
         context.fillStyle = &quot;rgba(255,0,0,0.4)&quot;;
         //缩放 旋转 平移  2 3  1 
         context.scale(0.5, 0.5);
         context.rotate(Math.PI / 4);
         context.translate(100, 100);
         context.fillRect(0, 0, 100, 100);

         context.restore(); //恢复到刚刚保存的状态
         context.save(); //保存了当前context的状态
         context.fillStyle = &quot;rgba(255,0,0,0.5)&quot;;
         //旋转 平移 缩放  3 1 2 
         context.rotate(Math.PI / 4);
         context.translate(100, 100);
         context.scale(0.5, 0.5);
         context.fillRect(0, 0, 100, 100);

         context.restore(); //恢复到刚刚保存的状态
         context.save(); //保存了当前context的状态
         context.fillStyle = &quot;rgba(255,0,0,1)&quot;;
         //旋转 缩放 平移   3 2 1 
         context.rotate(Math.PI / 4);
         context.scale(0.5, 0.5);
         context.translate(100, 100);
         context.fillRect(0, 0, 100, 100);

         //实验表明应该移动的是坐标轴
         //实验表明缩放的是坐标轴比例
         //实验表明旋转的是坐标轴
         //综合上述，因此平移 缩放 旋转 三者的顺序不同都将画出不同的结果
     } 
</code></pre><p>由于（平移，缩放，旋转）和（平移，旋转，缩放）一样</p>
<p>（缩放，选装，平移）和（旋转，缩放，平移）一样</p>
<p>所以实验结果只能看到“4”中情况，其实是有两种情况被覆盖了</p>
<p><img src="http://www.uml.org.cn/html/images/20120822415.png" alt="Mou"><br>下面给出平移，缩放，旋转先后顺序不同，坐标轴的变化图<br><img src="http://www.uml.org.cn/html/images/20120822416.png" alt="Mou">   </p>
<h3 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h3><p>context.transform(m11,m12,m21,m22,dx,dy)</p>
<p>所谓的矩阵变换其实是context内实现平移，缩放，旋转的一种机制</p>
<p>他的主要原理就是矩阵相乘</p>
<p>额，要讲解这个可以另开一个篇幅，庆幸的是已经有人做了总结，可以参考下面这篇文章</p>
<p><a href="http://hi.baidu.com/100912bb_bb/item/90c4a7489518b0fa1281daf1" target="_blank" rel="external">http://hi.baidu.com/100912bb_bb/item/90c4a7489518b0fa1281daf1</a></p>
<p>我们需要了解的是</p>
<p>context.translate(x,y) 等同于context.transform (1,0,0,1,x,y)或context.transform(0,1,1,0.x,y)</p>
<p>context.scale(x,y)等同于context.transform(x,0,0,y,0,0)或context.transform (0,y,x,0, 0,0);</p>
<p>context.rotate(θ)等同于 context.transform(Math.cos(θ<em>Math.PI/180)，Math.sin(θ</em>Math.PI/180), -Math.sin(θ<em>Math.PI/180),Math.cos(θ</em>Math.PI/180)，0，0） 或 context.transform(-Math.sin(θ<em>Math.PI/180),Math.cos(θ</em>Math.PI/180)， Math.cos(θ<em>Math.PI/180)，Math.sin(θ</em>Math.PI/180), 0，0）</p>
<h3 id="图形组合"><a href="#图形组合" class="headerlink" title="图形组合"></a>图形组合</h3><p>context.globalCompositeOperation=type</p>
<p>图形组合就是两个图形相互叠加了图形的表现形式,是后画的覆盖掉先画的呢，还是相互重叠的部分不显示等等，至于怎么显示就取决于type的值了</p>
<p>type：</p>
<p>source-over（默认值）:在原有图形上绘制新图形</p>
<p>destination-over:在原有图形下绘制新图形</p>
<p>source-in:显示原有图形和新图形的交集，新图形在上，所以颜色为新图形的颜色</p>
<p>destination-in:显示原有图形和新图形的交集，原有图形在上，所以颜色为原有图形的颜色</p>
<p>source-out:只显示新图形非交集部分</p>
<p>destination-out:只显示原有图形非交集部分</p>
<p>source-atop:显示原有图形和交集部分，新图形在上，所以交集部分的颜色为新图形的颜色</p>
<p>destination-atop:显示新图形和交集部分，新图形在下，所以交集部分的颜色为原有图形的颜色</p>
<p>lighter:原有图形和新图形都显示，交集部分做颜色叠加</p>
<p>xor:重叠飞部分不现实</p>
<p>copy:只显示新图形</p>
<p>文字看得人眼花缭乱，特意画图一张：回头一看惊觉打错字，图片的原型为圆形，你懂的- -<br><img src="http://www.uml.org.cn/html/images/20120822417.png" alt="Mou"><br>以下为实验代码</p>
<pre><code>View Code 
     function draw10(id) {
         var canvas = document.getElementById(id);
         if (canvas == null) {
             return false;
         }
         var context = canvas.getContext(&quot;2d&quot;);
         var oprtns = new Array(
         &quot;source-over&quot;,
         &quot;destination-over&quot;,
         &quot;source-in&quot;,
         &quot;destination-in&quot;,
         &quot;source-out&quot;,
         &quot;destination-out&quot;,
         &quot;source-atop&quot;,
         &quot;destination-atop&quot;,
         &quot;lighter&quot;,
         &quot;xor&quot;,         
         &quot;copy&quot;
         );
        var i = 0;//组合效果编号

        //结合setinterval动态显示组合
        var interal = setInterval(function () {
            if (i == 10) {
                i=0;
            }
            else {
                i++;
            }
            //蓝色矩形
            context.fillStyle = &quot;blue&quot;;
            context.fillRect(10, 10, 60, 60);
            //设置组合方式 
            context.globalCompositeOperation = oprtns[i];
            //设置新图形（红色圆形）
            context.beginPath();
            context.fillStyle = &quot;red&quot;;
            context.arc(60, 60, 30, 0, Math.PI * 2, false);
            context.fill();
       }, 1000);

     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822418.png" alt="Mou"><br>给图形绘制阴影</p>
<p>context.shadowOffsetX :阴影的横向位移量（默认值为0）</p>
<p>context.shadowOffsetY :阴影的纵向位移量（默认值为0）</p>
<p>context.shadowColor :阴影的颜色</p>
<p>context.shadowBlur :阴影的模糊范围（值越大越模糊）</p>
<p>先来个简单的例子</p>
<pre><code>View Code 
     function draw27(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&apos;2d&apos;);
         context.shadowOffsetX = 10;
         context.shadowOffsetY = 10;
         context.shadowColor = &apos;rgba(100,100,100,0.5)&apos;;
         context.shadowBlur = 1.5;
         context.fillStyle = &apos;rgba(255,0,0,0.5)&apos;;
         context.fillRect(100, 100, 200, 100);
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822419.png" alt="Mou"><br>再来个书本上的五角星的例子</p>
<pre><code>View Code 
     function create5Star(context) {
         var n = 0;
         var dx = 100;
         var dy = 0;

         var s = 50;
         //创建路径
         context.beginPath();
         context.fillStyle = &apos;rgba(255,0,0,0.5)&apos;;
         var x = Math.sin(0);
         var y = Math.cos(0);
         var dig = Math.PI / 5 * 4;
         for (var i = 0; i &lt; 5; i++) {
             var x = Math.sin(i * dig);
             var y = Math.cos(i * dig);
             context.lineTo(dx + x * s, dy + y * s);

         }
         context.closePath();

     }

     function draw11(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         context.fillStyle = &quot;#EEEEFF&quot;;
         context.fillRect(0, 0, 400, 300);

         context.shadowOffsetX = 10;
         context.shadowOffsetY = 10;
         context.shadowColor = &apos;rgba(100,100,100,0.5)&apos;;
         context.shadowBlur =5;
         //图形绘制
         context.translate(0, 50);
         for (var i = 0; i &lt; 3; i++) {
             context.translate(50, 50);
             create5Star(context);
             context.fill();
         }
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822420.png" alt="Mou"> </p>
<h3 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h3><p>绘图：context.drawImage</p>
<p>图像平铺：context.createPattern(image,type)</p>
<p>图像裁剪：context.clip()</p>
<p>像素处理：var imagedata=context.getImageData(sx,sy,sw,sh)</p>
<p>绘图 context.drawImage</p>
<p>context.drawImage(image,x,y)</p>
<p>image:Image对象var img=new Image(); img.src=”url(…)”;</p>
<p>x:绘制图像的x坐标</p>
<p>y:绘制图像的y坐标</p>
<p>context.drawImage(image,x,y,w,h)</p>
<p>image:Image对象var img=new Image(); img.src=”url(…)”;</p>
<p>x:绘制图像的x坐标</p>
<p>y:绘制图像的y坐标</p>
<p>w:绘制图像的宽度</p>
<p>h:绘制图像的高度</p>
<p>context.drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh):选取图像的一部分矩形区域进行绘制</p>
<p>image:Image对象var img=new Image(); img.src=”url(…)”;</p>
<p>sx：图像上的x坐标</p>
<p>sy：图像上的y坐标</p>
<p>sw：矩形区域的宽度</p>
<p>sh：矩形区域的高度</p>
<p>dx：画在canvas的x坐标</p>
<p>dy：画在canvas的y坐标</p>
<p>dw：画出来的宽度</p>
<p>dh：画出来的高度</p>
<p>最后一个方法可能比较拗，还是上图吧<br><img src="http://www.uml.org.cn/html/images/20120822421.png" alt="Mou"> </p>
<pre><code>   View Code 
    //drawImage(image,x,y)
    function draw28(id) {

    var image = new Image();

    image.src = &quot;Image/html5.jpg&quot;;
    var canvas = document.getElementById(id);

    if (canvas == null)
        return false;
    var context = canvas.getContext(&quot;2d&quot;);
    context.fillStyle = &quot;#EEEEFF&quot;;

    context.fillRect(0, 0, 400, 300);
    image.onload = function () {
        context.drawImage(image,0,0);
    }
}

//drawImage(image,x,y,w,h)
function draw12(id) {

    var image = new Image();

    image.src = &quot;Image/html5.jpg&quot;;
    var canvas = document.getElementById(id);

    if (canvas == null)
        return false;
    var context = canvas.getContext(&quot;2d&quot;);
    context.fillStyle = &quot;#EEEEFF&quot;;

    context.fillRect(0, 0, 400, 300);
    image.onload = function () {
        context.drawImage(image, 50, 50, 300, 200);
    }
}

//drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh)
function draw13(id){
    var image = new Image();
    image.src = &quot;Image/html5.jpg&quot;;
    var canvas = document.getElementById(id);

    if (canvas == null)
        return false;
    var context = canvas.getContext(&quot;2d&quot;);
    context.fillStyle = &quot;#EEEEFF&quot;;

    context.fillRect(0, 0, 400, 300);
    image.onload = function () {
        context.drawImage(image, 100, 100, 200, 150,50,50,300,200);//这里取的是实际尺寸
    }
} 
</code></pre><p>三个方法的运行结果如下：<br><img src="http://www.uml.org.cn/html/images/20120822422.png" alt="Mou"><br><img src="http://www.uml.org.cn/html/images/20120822423.png" alt="Mou"><br><img src="http://www.uml.org.cn/html/images/20120822424.png" alt="Mou"> </p>
<h3 id="图像平铺"><a href="#图像平铺" class="headerlink" title="图像平铺"></a>图像平铺</h3><p>context.createPattern(image,type)</p>
<p>type:</p>
<p>no-repeat:不平铺</p>
<p>repeat-x:横方向平铺</p>
<p>repeat-y:纵方向平铺</p>
<p>repeat:全方向平铺</p>
<p>类似图形组合，给出动态的切换平铺类型代码</p>
<pre><code>View Code 
     function draw14(id) {
         //传统的平铺是用for循环来处理的，现在直接调用接口
         var image = new Image();
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         var type = [&quot;no-repeat&quot;, &quot;repeat-x&quot;, &quot;repeat-y&quot;, &quot;repeat&quot;];
         var i = 0;
         image.src = &quot;Image/wordslogo.jpg&quot;;
         image.onload = function () {
             var interval = setInterval(function () {
                 //每次转换平铺类型清空
                 context.clearRect(0, 0, 400, 300);
                 if (i &gt;= 4) {
                     i = 0;
                 }
                 var ptrn = context.createPattern(image, type[i]);
                 context.fillStyle = ptrn;
                 context.fillRect(0, 0, 400, 300);
                 i++;
             }, 1000);
         };
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822424.png" alt="Mou"> </p>
<h3 id="图像裁剪："><a href="#图像裁剪：" class="headerlink" title="图像裁剪："></a>图像裁剪：</h3><p>context.clip()</p>
<p>context.clip()只绘制封闭路径区域内的图像，不绘制路径外部图像，用的时候</p>
<p>先创建裁剪区域</p>
<p>再绘制图像（之后绘制的图形都会采用这个裁剪区域，要取消这个裁剪区域就需要用到保存恢复状态，下面有讲）</p>
<p>给出圆形和星形的裁剪代码</p>
<pre><code>View Code 
     //图像裁剪
     function draw15(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         context.fillStyle = &quot;black&quot;;
         context.fillRect(0, 0, 400, 300);
         image = new Image();
         image.onload = function () {
             drawImg(context,image);
         }
         image.src = &quot;Image/html5.jpg&quot;
     }

     function drawImg(context, image) {
         //圆形裁剪区
         //createCircleClip(context)
         //星形裁剪区
         create5StarClip(context);
         context.drawImage(image,0,0);
     }

     function createCircleClip(context) {
         context.beginPath();
         context.arc(200, 150, 100, 0, Math.PI * 2, true);
         context.closePath();
         context.clip();
     }

     function create5StarClip(context) {
         var n = 0;
         var dx = 200;
         var dy = 135;
         var s = 150;
         context.beginPath();
         var x = Math.sin(0);
         var y = Math.cos(0);
         var dig = Math.PI / 5 * 4;
         for (var i = 0; i &lt; 5; i++) {
             var x = Math.sin(i * dig);
             var y = Math.cos(i * dig);
             context.lineTo(dx + x * s, dy + y * s);
         }
         context.closePath();
         context.clip();
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822426.png" alt="Mou"><br><img src="http://www.uml.org.cn/html/images/20120822427.png" alt="Mou"> </p>
<h3 id="像素处理："><a href="#像素处理：" class="headerlink" title="像素处理："></a>像素处理：</h3><p>获取像素颜色数组： var imagedata=context.getImageData(sx,sy,sw,sh)</p>
<p>sx:cavas的x轴坐标点</p>
<p>sy:canvas的y轴坐标点</p>
<p>sw:距离x的宽度</p>
<p>sh:距离y的高度</p>
<p>可以利用context.getImageData返回的一个像素颜色数组，顺序是所取像素范围的从左到右，从上到下，数组的元素是（所有图形，包括图片，和绘制的图形）每个像素的rgba</p>
<p>[r1,g1,b1,a1,r2,g2,b2,a2…]</p>
<p>设置像素颜色：context.putImageData(imagedata,dx,dy,dirtyX,dirtyY,dirtyWidth,dirtyHeight)</p>
<p>对imagedata数组中的各个像素的r、g、b、a值进行修改，再调用putImageData方法进行绘制</p>
<p>imagedata:修改后的imagedata</p>
<p>dx:重绘图像的起点横坐标（重绘的起点和原来的图像一致的话就会把原来的图形覆盖掉，看起来就像是原来的图像变成现在的图像一样）</p>
<p>dy:重绘图像的起点纵坐标</p>
<p>//以下可选参数，设置重绘的矩形范围，如果缺省，默认会重绘所有的imegedata</p>
<p>dirtyX:矩形左上角x轴坐标</p>
<p>dirtyY:矩形左上角y轴坐标</p>
<p>dirtyWidth:矩形长度</p>
<p>dirtyHeight:矩形高度</p>
<pre><code>View Code 
     function draw16(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         context.fillStyle = &apos;red&apos;
         //在右下角画一个正方形
         context.fillRect(250,250,150,50);
         var image = new Image();
         image.src = &quot;Image/html5.jpg&quot;;

         image.onload = function () {
             //在左上角画一幅图片
             context.drawImage(image, 0, 0,200,200);

             //实验证明imagedata取的是canvas所在范围画的图形，不止是图片
             //不会取该区域内是空白的canvas的像素
             var imagedata = context.getImageData(0, 0, 400, 300);

             //修改imagedata
             for (var i = 0, n = imagedata.data.length; i &lt; n; i += 4) {

                 imagedata.data[i + 0] = 255 - imagedata.data[i + 0]; //red;
                 imagedata.data[i + 1] = 255 - imagedata.data[i + 1]; //green
                 imagedata.data[i + 2] = 255 - imagedata.data[i + 2]; //blue
                 //imagedata.data[i + 3] = 255 - imagedata.data[i + 3]; //a
             }
             context.putImageData(imagedata, 0, 0);
         }
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822428.png" alt="Mou"> </p>
<h3 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h3><p>填充文字：context.fillText(text,x,y)</p>
<p>绘制文字轮廓 context.strokeText(text,x,y)</p>
<p>text:要绘制的文字</p>
<p>x:文字起点的x坐标轴</p>
<p>y:文字起点的y坐标轴</p>
<p>context.font:设置字体样式</p>
<p>context.textAlign:水平对齐方式</p>
<p>start、end、right、center</p>
<p>context.textBaseline:垂直对齐方式</p>
<p>top、hanging、middle、alphabetic、ideographic、bottom</p>
<p>var length=context.measureText(text):计算字体长度(px)那么能不能计算高度啊，很遗憾，不能</p>
<pre><code>View Code 
     function draw17(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         context.fillStyle = &quot;#EEEEFF&quot;;
         context.fillRect(0,0,400,300);
         context.fillStyle = &quot;#00f&quot;;
         context.font = &quot;italic 30px sans-serif&quot;;
         context.textBaseline = &apos;top&apos;;
         //填充字符串
         var txt=&quot;fill示例文字&quot;
         context.fillText(txt, 0, 0);
         var length=context.measureText(txt);
         context.fillText(&quot;长&quot; + length.width + &quot;px&quot;, 0, 50);
         context.font = &quot;bolid 30px sans-serif&quot;;
         txt = &quot;stroke示例文字&quot;;
         length = context.measureText(txt);
         context.strokeText(txt,0,100);
         context.fillText(&quot;长&quot; + length.width + &quot;px&quot;, 0, 150);
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822429.png" alt="Mou"> </p>
<h3 id="保存和恢复状态"><a href="#保存和恢复状态" class="headerlink" title="保存和恢复状态"></a>保存和恢复状态</h3><p>保存：context.save()</p>
<p>恢复：context.restore()</p>
<p>在上面的裁剪图片提过，一旦设定了裁剪区域，后来绘制的图形都只显示裁剪区域内的内容，要“取消”这个裁剪区域才能正常绘制其他图形，其实这个“取消”是利用save（）方法和restore（）方法来实现的。</p>
<p>context.save()：调用该方法，会保存当前context的状态、属性（把他理解成游戏存档）</p>
<p>context.restore():调用该方法就能恢复到save时候context的状态、属性（游戏回档）</p>
<pre><code>View Code 
function draw18(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         context.fillStyle = &quot;red&quot;;
         context.save(); //保存了当前context的状态
         context.fillStyle = &quot;black&quot;;
         context.fillRect(0, 0, 100, 100);
         context.restore();//恢复到刚刚保存的状态
         context.fillRect(0,120,100,100);
     } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822430.png" alt="Mou"> </p>
<h3 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h3><p>canvas.toDataURL(MIME)</p>
<p>在canvas中绘出的图片只是canvas标签而已，并非是真正的图片，是不能右键，另存为的，我们可以利用canvas.toDataURL()这个方法把canvas绘制的图形生成一幅图片，生成图片后，就能对图片进行相应的操作了。</p>
<pre><code>View Code 
     function draw19(id) {
         var canvas = document.getElementById(id);
         if (canvas == null)
             return false;
         var context = canvas.getContext(&quot;2d&quot;);
         context.fillStyle = &quot;rgb(0,0,225)&quot;;
         context.fillRect(0, 0, canvas.width, canvas.height);
         context.fillStyle = &quot;rgb(255,255,0)&quot;;
         context.fillRect(10, 20, 50, 50);
         //把图像保存到新的窗口
         var w=window.open(canvas.toDataURL(&quot;image/jpeg&quot;),&quot;smallwin&quot;,&quot;width=400,height=350&quot;);
    } 
</code></pre><p><img src="http://www.uml.org.cn/html/images/20120822431.png" alt="Mou">        </p>
<h3 id="结合setInterval制作动画"><a href="#结合setInterval制作动画" class="headerlink" title="结合setInterval制作动画"></a>结合setInterval制作动画</h3><p>基本原理就是定时清除整个canvas重新绘制，下面给出“我弹、我弹、我弹弹弹”的代码 （额、名字而已）</p>
<p>小矩形在矩形区域移动，碰到矩形区域的边缘反弹</p>
<pre><code>View Code 
    function draw20(id) {
        var canvas = document.getElementById(id);
        if (canvas == null)
            return false;
        var context = canvas.getContext(&quot;2d&quot;);

        var interal = setInterval(function () {
            move(context);
        }, 1);
    }

    var x = 100;//矩形开始坐标
    var y = 100;//矩形结束坐标
    var mx = 0;//0右1左
    var my = 0; //0下1上
    var ml = 1;//每次移动长度
    var w = 20;//矩形宽度
    var h = 20;//矩形高度
    var cw = 400;//canvas宽度
    var ch = 300; //canvas高度


    function move(context) {
        context.clearRect(0, 0, 400, 300);
        context.fillStyle = &quot;#EEEEFF&quot;;
        context.fillRect(0, 0, 400, 300);
        context.fillStyle = &quot;red&quot;;
        context.fillRect(x, y, w, h);       
        if (mx == 0) {
            x = x + ml;
            if (x &gt;= cw-w) {
                mx = 1;
            }
        }
        else {
            x = x - ml;
            if (x &lt;= 0) {
                mx = 0;
            }
        }
        if (my == 0) {
            y = y + ml;
            if (y &gt;= ch-h) {
                my = 1;
            }
        }
        else {
            y = y - ml;
            if (y &lt;= 0) {
                my = 0;
            }
        }

    } 
</code></pre><p> <img src="http://www.uml.org.cn/html/images/20120822432.png" alt="Mou">  </p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>历时一天半，本来以为可以玩转的，写下来才发现要玩转canvas还需要很多的实践，这个道理应该是适用所有的技术的，做人啊，就得谦虚点。本文如有错误，请及时留言给我纠正，希望能给正在学canvas绘图的童鞋有所帮助</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/16/canvas画图/" class="archive-article-date">
  	<time datetime="2016-11-16T12:00:25.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-16</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
  
    <a href="/2016/11/15/Vue-js/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Vue.js</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>







<!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="玩转html5-canvas画图" data-title="canvas画图" data-url="http://yoursite.com/2016/11/16/canvas画图/"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"qianjenbo"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 qianjenbo
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/qianjianbo/">啵啵啵博客园</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/Jasonellen/">奋斗蚁博客园</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://jasonellen.github.io/">奋斗蚁github</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://yang867381349.github.io">杨军权githob</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://duhan96.github.io/">杜🐶</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jianshu.com/users/926dbfef1d19/latest_articles">杜涵简书</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>